// ============================================
// PLANNER COMPONENT
// ============================================

import { getAllPizzaNights, createPizzaNight, deletePizzaNight, completePizzaNight, updatePizzaNight, getAllRecipes, getAllGuests, addGuest, updateGuest, deleteGuest, getRecipeById, getPizzaNightById, getUserSettings } from '../modules/database.js';
import { formatDate, formatDateForInput, getNextSaturdayEvening, confirm, formatQuantity, showToast } from '../utils/helpers.js';
import { openModal, closeModal } from '../modules/ui.js';
import { getUser } from '../modules/auth.js';
import { getCookingInstructions } from '../utils/cookingCalculator.js';
import { DOUGH_TYPES, DOUGH_RECIPES, PREPARATIONS, RECIPE_TAGS } from '../utils/constants.js';
import { getRecipeDoughType } from '../utils/doughHelper.js';
console.log('üöÄ Planner.js module loaded! V2');
import { state } from '../store.js';
import { generateShoppingList, downloadShoppingList } from '../modules/shopping.js';
import { DEFAULT_GUEST_COUNT } from '../utils/constants.js';
import { calculateDoughIngredients, copyDoughRecipeToClipboard } from '../utils/doughCalculator.js';


export async function renderPlanner(appState) {
  await renderPizzaNights();
  setupPlannerListeners();

  // Inject live mode HTML structure if not already present
  if (!document.getElementById('liveModeContainer')) {
    const liveModeHTML = `
  <div id="liveModeContainer" style="display: none;">
        <!-- Header -->
        <div class="live-header">
          <div class="progress-indicator">Pizza 1 di 1</div>
          <button class="btn-exit" onclick="window.exitLiveMode()">‚úï Esci</button>
        </div>

        <!-- Current Pizza Display -->
        <div class="live-pizza-card">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
             <h2 class="pizza-name" style="margin: 0;">Caricamento...</h2>
             <div>
               <button id="btnUploadPhoto" class="btn btn-sm btn-secondary" onclick="document.getElementById('livePhotoInput').click()">
                 <span>üì∑</span> Foto
               </button>
               <input type="file" id="livePhotoInput" accept="image/*" style="display: none;" onchange="window.handlePizzaPhotoUploadV2(this)">
             </div>
          </div>

          <!-- Dedicated Image Container -->
          <div id="liveImageContainer" style="margin: 1rem 0; min-height: 0;"></div>
          
          <!-- Before Cooking Section -->
          <div class="cooking-phase-section">
            <h3 style="color: var(--color-primary-light); font-size: 1.25rem; margin-bottom: 1rem;">üî• Prima cottura</h3>
            <div id="beforeCookingContent">
              <!-- Populated by JS -->
            </div>
          </div>

          <!-- Cooking Instructions -->
          <div class="cooking-section">
            <h3>üî• Cottura</h3>
            <p id="liveCookingInstructions">Forno a 250¬∞C per 8-10 minuti</p>
          </div>
          
          <!-- After Cooking Section -->
          <div class="cooking-phase-section">
            <h3 style="color: var(--color-accent-light); font-size: 1.25rem; margin-bottom: 1rem;">‚ú® Dopo cottura</h3>
            <div id="afterCookingContent">
              <!-- Populated by JS -->
            </div>
          </div>
        </div>

        <!-- Navigation -->
  <div class="live-footer">
    <button class="btn btn-secondary" onclick="window.previousPizza()" id="btnPrev" style="display: none;">
      ‚Üê Precedente
    </button>
    <button class="btn btn-primary" onclick="window.nextPizza()" id="btnNext">
      Prossima ‚Üí
    </button>
    <button class="btn btn-success" onclick="window.completePizzaNightLive()" id="btnComplete" style="display: none;">
      ‚úì Completa Serata
    </button>
  </div>
      </div >
  `;

    document.body.insertAdjacentHTML('beforeend', liveModeHTML);
  }
}

// ============================================
// PLANNER FILTER STATE
// ============================================

const plannerFilterState = {
  selectedTag: null,
  selectedIngredient: 'all',
  sortBy: 'az'
};

// Track suggested ingredients for auto/mixed mode
let plannerSuggestedIngredients = [];

/**
 * Resets all planner state variables to ensure a clean start for new sessions
 */
function resetPlannerState() {
  plannerSuggestedIngredients = [];
  manuallySelectedPizzaIds = [];
  currentGeneratedPizzas = [];
  autoGeneratedPizzaIds.clear();

  // Reset filters
  plannerFilterState.selectedTag = null;
  plannerFilterState.selectedIngredient = 'all';
  plannerFilterState.sortBy = 'az';

  console.log('üîÑ Planner state reset');
}

// ============================================
// NEW PIZZA NIGHT MODAL
// ============================================

async function showNewPizzaNightModal() {
  resetPlannerState();

  const modalContent = `
    <div class="modal-header">
      <h2 class="modal-title">Nuova Serata Pizza</h2>
      <button class="modal-close" onclick="window.closeModal()">√ó</button>
    </div>
    <div class="modal-body">
      <form id="newPizzaNightForm">
        <!-- ... existing fields ... -->
        <div class="form-group">
          <label class="form-label">Nome Serata *</label>
          <input type="text" class="form-input" name="name" required placeholder="es. Pizza con gli amici">
        </div>
        
        <div class="form-group">
          <label class="form-label">Data e Ora *</label>
          <input type="datetime-local" class="form-input" name="date" required value="${formatDateForInput(getNextSaturdayEvening())}">
        </div>
        
        <div class="form-group">
          <label class="form-label">Numero Ospiti *</label>
          <input type="number" class="form-input" name="guestCount" id="guestCountInput" required value="0" min="0">
        </div>

        <div class="form-group">
          <label class="form-label">Seleziona Ospiti (Opzionale)</label>
          <p style="font-size: 0.875rem; color: var(--color-gray-400); margin-bottom: 0.5rem;">Seleziona gli ospiti da invitare. Potrai inviare email dopo aver creato la serata.</p>
          <div id="guestSelection" style="max-height: 150px; overflow-y: auto; margin-bottom: 1rem; border: 1px solid rgba(255,255,255,0.1); border-radius: 0.5rem; padding: 0.25rem;">
            <!-- Guests will be loaded here -->
            <p class="text-muted text-sm">‚è≥ Caricamento ospiti...</p>
          </div>
        </div>
        
        <div class="form-group" style="background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
          <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 1.1rem; margin-bottom: 1rem;">
            <span>ü•£</span>
            <span>Tipo di Impasto per la Serata *</span>
          </label>
          <p style="color: var(--color-gray-300); font-size: 0.875rem; margin-bottom: 1rem;">
            Scegli quale impasto preparare. Tutte le pizze della serata useranno questo impasto.
          </p>
          <select id="selectedDoughType" name="selectedDough" class="form-input" required style="font-size: 1rem; padding: 0.75rem;">
            <option value="" style="color: #000; background: #fff;">Seleziona un impasto...</option>
            ${DOUGH_RECIPES.map(d => `
              <option value="${d.type}" style="color: #000; background: #fff;">
                ${d.type} - ${d.hydration}% idratazione (${d.difficulty})
              </option>
            `).join('')}
          </select>
          <div id="doughInfo" style="margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem; display: none;">
            <!-- Dough info will be shown here -->
          </div>
          
          <!-- DOUGH CALCULATOR -->
          <div id="doughCalculator" style="margin-top: 1.5rem; padding: 1.5rem; background: rgba(34, 197, 94, 0.1); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 0.75rem; display: none;">
            <h4 style="margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem; color: var(--color-success);">
              <span>üìä</span>
              <span>Calcolo Impasto</span>
            </h4>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
              <div>
                <label class="form-label" style="font-size: 0.875rem;">Peso per pizza (g)</label>
                <input type="number" id="doughWeightPerPizza" class="form-input" value="250" min="150" max="350" step="10" style="padding: 0.5rem;">
                <small style="color: var(--color-gray-400); font-size: 0.75rem;">Consigliato: 200-280g</small>
              </div>
              
              <div>
                <label class="form-label" style="font-size: 0.875rem;">Panetti di scorta</label>
                <input type="number" id="doughExtraBalls" class="form-input" value="0" min="0" max="5" step="1" style="padding: 0.5rem;">
                <small style="color: var(--color-gray-400); font-size: 0.75rem;">Opzionale (0-5)</small>
              </div>
            </div>
            
            <div id="doughCalculationResult" style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 1rem; display: none;">
              <!-- Calculation results will be shown here -->
            </div>
          </div>
        </div>
        
        <div class="form-group" style="background: rgba(99, 102, 241, 0.1); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
          <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 1.1rem; margin-bottom: 1rem;">
            <span>üéØ</span>
            <span>Modalit√† Selezione Pizze</span>
          </label>
          <p style="color: var(--color-gray-300); font-size: 0.875rem; margin-bottom: 1rem;">
            Scegli come selezionare le pizze per la serata
          </p>
          
          <div style="display: flex; flex-direction: column; gap: 0.75rem;">
            <label style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 0.5rem; cursor: pointer; transition: all 0.2s;">
              <input type="radio" name="selectionMode" value="manual" checked style="width: 18px; height: 18px;">
              <div>
                <div style="font-weight: 600; margin-bottom: 0.25rem;">‚úã Manuale</div>
                <div style="font-size: 0.875rem; color: var(--color-gray-400);">Scegli tu tutte le pizze dalla lista</div>
              </div>
            </label>
            
            <label style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 0.5rem; cursor: pointer; transition: all 0.2s;">
              <input type="radio" name="selectionMode" value="auto" style="width: 18px; height: 18px;">
              <div>
                <div style="font-weight: 600; margin-bottom: 0.25rem;">ü§ñ Automatica</div>
                <div style="font-size: 0.875rem; color: var(--color-gray-400);">L'AI sceglie tutto ottimizzando ingredienti</div>
              </div>
            </label>
            
            <label style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 0.5rem; cursor: pointer; transition: all 0.2s;">
              <input type="radio" name="selectionMode" value="mixed" style="width: 18px; height: 18px;">
              <div>
                <div style="font-weight: 600; margin-bottom: 0.25rem;">‚≠ê Mista (Consigliata)</div>
                <div style="font-size: 0.875rem; color: var(--color-gray-400);">Tu scegli alcune, l'AI completa ottimizzando</div>
              </div>
            </label>
          </div>
        </div>
        
        <!-- Ingredients Suggestions (for Auto/Mixed mode) -->
        <div id="plannerSuggestionsUI" class="form-group" style="display: none; background: rgba(99, 102, 241, 0.05); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.5rem;">
          <label class="form-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 1rem; color: var(--color-primary-light);">
            <span>üí°</span>
            <span>Suggerimenti Ingredienti</span>
          </label>
          <p style="color: var(--color-gray-400); font-size: 0.8125rem; margin-bottom: 1rem;">
            Pizze che contengono questi ingredienti saranno favorite.
          </p>
          
          <div id="plannerIngredientsSelector" style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem;">
            <!-- Populated via JS -->
          </div>
          <div id="plannerSelectedIngredients" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            <!-- Selected chips -->
          </div>
        </div>
        
        <!-- Auto Mode UI -->
        <div id="autoModeUI" class="form-group" style="display: none; background: rgba(34, 197, 94, 0.1); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
          <label class="form-label">Numero di pizze da generare</label>
          <input type="number" id="autoNumPizzas" class="form-input" value="5" min="2" max="20" style="margin-bottom: 1rem;">
          <button type="button" class="btn btn-primary" onclick="window.generateAutoPizzas()" style="width: 100%;">
            üé≤ Genera Proposte Ottimizzate
          </button>
          <div id="autoResults" style="margin-top: 1rem; display: none;"></div>
        </div>
        
        <!-- Mixed Mode UI -->
        <div id="mixedModeUI" class="form-group" style="display: none; background: rgba(251, 146, 60, 0.1); border: 2px solid rgba(251, 146, 60, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
          <div style="margin-bottom: 1rem;">
            <label class="form-label">üìå Pizze Fisse (scelte da te)</label>
            <div id="fixedPizzasList" style="margin-top: 0.5rem; min-height: 40px; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 0.5rem;">
              <p class="text-muted text-sm">Seleziona pizze dalla lista sotto...</p>
            </div>
          </div>
          <div style="margin-bottom: 1rem;">
            <label class="form-label">ü§ñ Pizze da generare automaticamente</label>
            <input type="number" id="mixedNumToGenerate" class="form-input" value="3" min="1" max="15">
          </div>
          <button type="button" class="btn btn-primary" onclick="window.generateMixedPizzas()" style="width: 100%;" disabled id="mixedGenerateBtn">
            üé≤ Completa Selezione
          </button>
          <div id="mixedResults" style="margin-top: 1rem; display: none;"></div>
        </div>
        
        <!-- Metrics Display -->
        <div id="metricsDisplay" style="display: none; background: rgba(99, 102, 241, 0.1); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
          <h4 style="margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem;">
            <span>üìä</span>
            <span>Metriche Ottimizzazione</span>
          </h4>
          <div id="metricsContent"></div>
        </div>
        
        <div class="form-group" id="manualPizzaSelection">
          <label class="form-label">Seleziona Pizze</label>
          
          <!-- Filter UI -->
          <div style="margin-bottom: 1rem;">
            <!-- Tag filters -->
            <div id="plannerTagFilters" class="filter-chips" style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.75rem;"></div>
            
            <!-- Dropdowns -->
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
              <select id="plannerIngredientFilter" class="sort-select" style="min-width: 160px;">
                <option value="all">ü•ò Tutti gli ingredienti</option>
              </select>
              
              <select id="plannerRecipeSort" class="sort-select">
                <option value="az">üî§ A-Z</option>
                <option value="za">üî§ Z-A</option>
                <option value="rating">‚≠ê Rating</option>
                <option value="newest">üìÖ Pi√π recenti</option>
                <option value="oldest">üìÖ Meno recenti</option>
              </select>
            </div>
          </div>

          <div id="pizzaSelection" style="max-height: 300px; overflow-y: auto;">
             <!-- Pizza list populated via JS -->
             <p class="text-muted">‚è≥ Caricamento pizze...</p>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Note</label>
          <textarea class="form-textarea" name="notes" placeholder="Note aggiuntive..."></textarea>
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="window.closeModal()">Annulla</button>
      <button class="btn btn-accent" onclick="window.submitNewPizzaNight()">
        <span>‚ûï</span>
        Crea Serata
      </button>
    </div>
`;

  // SHOW MODAL IMMEDIATELY - This is the key optimization!
  openModal(modalContent);

  // Reset filter state
  plannerFilterState.selectedTag = null;
  plannerFilterState.selectedIngredient = 'all';
  plannerFilterState.sortBy = 'az';

  // Setup mode selection listeners (synchronous, no data needed)
  setupModeListeners();

  // Setup dough selection listener (synchronous, uses DOUGH_RECIPES constant)
  setupDoughSelectionListener();

  // Load all data asynchronously in background
  loadModalDataAsync();
}

// NEW: Setup dough selection listener
function setupDoughSelectionListener() {
  const doughSelect = document.getElementById('selectedDoughType');
  if (doughSelect) {
    doughSelect.addEventListener('change', (e) => {
      const selectedDoughType = e.target.value;
      const doughInfoDiv = document.getElementById('doughInfo');

      if (selectedDoughType && doughInfoDiv) {
        const dough = DOUGH_RECIPES.find(d => d.type === selectedDoughType);
        if (dough) {
          doughInfoDiv.style.display = 'block';
          doughInfoDiv.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 0.75rem;">
              <div style="text-align: center;">
                <div style="font-size: 0.75rem; color: var(--color-gray-400);">Idratazione</div>
                <div style="font-weight: 700; color: var(--color-primary-light);">${dough.hydration}%</div>
              </div>
              <div style="text-align: center;">
                <div style="font-size: 0.75rem; color: var(--color-gray-400);">Lievitazione</div>
                <div style="font-weight: 600; font-size: 0.875rem;">${dough.fermentation}</div>
              </div>
              <div style="text-align: center;">
                <div style="font-size: 0.75rem; color: var(--color-gray-400);">Resa</div>
                <div style="font-weight: 700; color: var(--color-accent-light);">${dough.yield} pizze</div>
              </div>
              <div style="text-align: center;">
                <div style="font-size: 0.75rem; color: var(--color-gray-400);">Difficolt√†</div>
                <div style="font-weight: 600;">${dough.difficulty}</div>
              </div>
            </div >
  <p style="font-size: 0.875rem; color: var(--color-gray-300); margin: 0;">
    ${dough.description}
  </p>
`;
        }
      } else if (doughInfoDiv) {
        doughInfoDiv.style.display = 'none';
      }

      // Update dough calculator visibility
      updateDoughCalculator();
    });
  }
}

// NEW: Load all modal data asynchronously
async function loadModalDataAsync() {
  try {
    // Load recipes first (most important)
    const recipes = await getAllRecipes();

    // Update pizza selection UI
    populatePlannerIngredientFilter(recipes);
    renderPlannerTagFilters();
    const filtered = filterAndSortPlannerRecipes(recipes);
    renderPizzaSelectionList(filtered);

    // Setup filter event listeners
    setupFilterListeners(recipes);

    // Populate suggested ingredients selector
    populatePlannerIngredientsSelector(recipes);

    // Load guests (can happen in parallel, less critical)
    await loadGuestsIntoModal();

    // Setup guest count auto-update
    setupGuestCountListener();

    // Setup dough calculator listeners
    setupDoughCalculatorListeners();

  } catch (error) {
    console.error('Error loading modal data:', error);
    const pizzaSelection = document.getElementById('pizzaSelection');
    if (pizzaSelection) {
      pizzaSelection.innerHTML = '<p style="color: var(--color-error);">‚ùå Errore nel caricamento dati</p>';
    }
  }
}

// NEW: Setup filter event listeners
function setupFilterListeners(recipes) {
  const tagFiltersContainer = document.getElementById('plannerTagFilters');
  if (tagFiltersContainer) {
    tagFiltersContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('filter-chip')) {
        const tag = e.target.dataset.tag;
        plannerFilterState.selectedTag =
          plannerFilterState.selectedTag === tag ? null : tag;
        renderPlannerTagFilters();
        const filtered = filterAndSortPlannerRecipes(recipes);
        renderPizzaSelectionList(filtered);
      }
    });
  }

  const ingredientFilter = document.getElementById('plannerIngredientFilter');
  if (ingredientFilter) {
    ingredientFilter.addEventListener('change', (e) => {
      plannerFilterState.selectedIngredient = e.target.value;
      const filtered = filterAndSortPlannerRecipes(recipes);
      renderPizzaSelectionList(filtered);
    });
  }

  const sortSelect = document.getElementById('plannerRecipeSort');
  if (sortSelect) {
    sortSelect.addEventListener('change', (e) => {
      plannerFilterState.sortBy = e.target.value;
      const filtered = filterAndSortPlannerRecipes(recipes);
      renderPizzaSelectionList(filtered);
    });
  }
}

// NEW: Setup guest count auto-update listener
function setupGuestCountListener() {
  const guestSelectionContainer = document.getElementById('guestSelection');
  const guestCountInput = document.querySelector('input[name="guestCount"]');
  if (guestSelectionContainer && guestCountInput) {
    guestSelectionContainer.addEventListener('change', (e) => {
      if (e.target.name === 'selectedGuests') {
        const checkedGuests = guestSelectionContainer.querySelectorAll('input[name="selectedGuests"]:checked');
        const checkedCount = checkedGuests.length;
        if (checkedCount > 0) {
          guestCountInput.value = checkedCount;
        } else {
          // If no guests selected, reset to default
          guestCountInput.value = DEFAULT_GUEST_COUNT;
        }
      }
    });
  }
}

// ============================================
// DOUGH CALCULATOR
// ============================================

/**
 * Update dough calculator visibility and calculation
 * Shows calculator when dough type is selected AND (pizzas selected OR guest count > 0)
 */
function updateDoughCalculator() {
  const doughSelect = document.getElementById('selectedDoughType');
  const doughCalculator = document.getElementById('doughCalculator');
  const guestCountInput = document.getElementById('guestCountInput');

  if (!doughSelect || !doughCalculator) return;

  const selectedDoughType = doughSelect.value;
  const selectedPizzas = getSelectedPizzasCount();
  const guestCount = guestCountInput ? parseInt(guestCountInput.value) || 0 : 0;

  // Show calculator if dough selected AND (pizzas selected OR guests entered)
  if (selectedDoughType && (selectedPizzas > 0 || guestCount > 0)) {
    doughCalculator.style.display = 'block';
    calculateAndRenderDough();
  } else {
    doughCalculator.style.display = 'none';
  }
}

/**
 * Get count of selected pizzas
 */
function getSelectedPizzasCount() {
  const checkedBoxes = document.querySelectorAll('#pizzaSelection input[type="checkbox"]:checked');
  return checkedBoxes.length;
}

/**
 * Calculate and render dough ingredients
 */
function calculateAndRenderDough() {
  const doughSelect = document.getElementById('selectedDoughType');
  const weightInput = document.getElementById('doughWeightPerPizza');
  const extraBallsInput = document.getElementById('doughExtraBalls');
  const resultDiv = document.getElementById('doughCalculationResult');

  if (!doughSelect || !weightInput || !extraBallsInput || !resultDiv) return;

  const selectedDoughType = doughSelect.value;
  let numPizzas = getSelectedPizzasCount();
  const guestCountInput = document.getElementById('guestCountInput');
  const manualGuestCount = guestCountInput ? parseInt(guestCountInput.value) || 0 : 0;

  // Use manual guest count as fallback if no specific pizzas are checked
  if (numPizzas === 0) {
    numPizzas = manualGuestCount;
  }

  const weightPerPizza = parseInt(weightInput.value) || 250;
  const extraBalls = parseInt(extraBallsInput.value) || 0;

  if (!selectedDoughType || numPizzas <= 0) {
    resultDiv.style.display = 'none';
    return;
  }

  // Find the dough recipe
  const doughRecipe = DOUGH_RECIPES.find(d => d.type === selectedDoughType);
  if (!doughRecipe) return;

  // Calculate ingredients
  const calculation = calculateDoughIngredients(doughRecipe, numPizzas, weightPerPizza, extraBalls);

  if (!calculation) {
    resultDiv.style.display = 'none';
    return;
  }

  // Render results
  renderDoughCalculationResults(calculation, resultDiv);
}

/**
 * Render dough calculation results
 */
function renderDoughCalculationResults(calculation, container) {
  container.innerHTML = `
    <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <strong style="color: var(--color-success);">
          ${calculation.requestedPizzas} pizze${calculation.extraDoughBalls > 0 ? ` + ${calculation.extraDoughBalls} di scorta` : ''}
        </strong>
        <span style="color: var(--color-gray-400); font-size: 0.875rem;">
          ${calculation.weightPerPizza}g/pizza
        </span>
      </div>
      <div style="color: var(--color-gray-300); font-size: 0.875rem;">
        Peso totale impasto: <strong>${calculation.totalWeight}g</strong>
      </div>
    </div>
    
    <div style="margin-bottom: 1rem;">
      <h5 style="margin: 0 0 0.75rem 0; font-size: 0.9375rem; color: var(--color-primary-light);">
        üßæ Ingredienti Necessari:
      </h5>
      <ul style="list-style: none; padding: 0; margin: 0; display: grid; gap: 0.5rem;">
        ${calculation.ingredients.map(ing => `
          <li style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.375rem;">
            <span style="color: var(--color-gray-200);">${ing.name}</span>
            <strong style="color: var(--color-white);">${ing.calculatedQuantity} ${ing.unit}</strong>
          </li>
        `).join('')}
      </ul>
    </div>
    
    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
      <button type="button" class="btn btn-sm btn-secondary" onclick="window.copyDoughRecipe()" style="flex: 1; min-width: 120px;">
        üìã Copia Ricetta
      </button>
    </div>
  `;
  container.style.display = 'block';
}

/**
 * Setup dough calculator event listeners
 */
function setupDoughCalculatorListeners() {
  const weightInput = document.getElementById('doughWeightPerPizza');
  const extraBallsInput = document.getElementById('doughExtraBalls');
  const pizzaSelection = document.getElementById('pizzaSelection');
  const guestCountInput = document.getElementById('guestCountInput');

  // Update on weight change
  if (weightInput) {
    weightInput.addEventListener('input', () => {
      calculateAndRenderDough();
    });
  }

  // Update on extra balls change
  if (extraBallsInput) {
    extraBallsInput.addEventListener('input', () => {
      calculateAndRenderDough();
    });
  }

  // Update when pizzas are selected/deselected
  if (pizzaSelection) {
    pizzaSelection.addEventListener('change', (e) => {
      if (e.target.type === 'checkbox') {
        updateDoughCalculator();
      }
    });
  }

  // Update when guest count changes
  if (guestCountInput) {
    guestCountInput.addEventListener('input', () => {
      updateDoughCalculator();
    });
  }
}

/**
 * Global function to copy dough recipe to clipboard
 */
window.copyDoughRecipe = async function () {
  const doughSelect = document.getElementById('selectedDoughType');
  const weightInput = document.getElementById('doughWeightPerPizza');
  const extraBallsInput = document.getElementById('doughExtraBalls');

  if (!doughSelect) return;

  const selectedDoughType = doughSelect.value;
  const numPizzas = getSelectedPizzasCount();
  const weightPerPizza = parseInt(weightInput?.value) || 250;
  const extraBalls = parseInt(extraBallsInput?.value) || 0;

  const doughRecipe = DOUGH_RECIPES.find(d => d.type === selectedDoughType);
  if (!doughRecipe) return;

  const calculation = calculateDoughIngredients(doughRecipe, numPizzas, weightPerPizza, extraBalls);

  if (calculation) {
    const success = await copyDoughRecipeToClipboard(calculation);
    if (success) {
      showToast('Ricetta copiata negli appunti!', 'success');
    } else {
      showToast('Errore nella copia', 'error');
    }
  }
};


// Setup listeners for selection mode radio buttons
function setupModeListeners() {
  const modeRadios = document.querySelectorAll('input[name="selectionMode"]');
  const manualSection = document.getElementById('manualPizzaSelection');
  const autoUI = document.getElementById('autoModeUI');
  const mixedUI = document.getElementById('mixedModeUI');

  modeRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      const mode = e.target.value;

      // Hide all mode-specific UIs
      if (manualSection) manualSection.style.display = 'none';
      if (autoUI) autoUI.style.display = 'none';
      if (mixedUI) mixedUI.style.display = 'none';

      const suggestionsUI = document.getElementById('plannerSuggestionsUI');
      if (suggestionsUI) {
        suggestionsUI.style.display = (mode === 'auto' || mode === 'mixed') ? 'block' : 'none';
      }

      // Show selected mode UI
      if (mode === 'manual' && manualSection) {
        manualSection.style.display = 'block';
      } else if (mode === 'auto' && autoUI) {
        autoUI.style.display = 'block';
      } else if (mode === 'mixed' && mixedUI) {
        mixedUI.style.display = 'block';
        manualSection.style.display = 'block'; // Show pizza list for selection
        setupMixedModeListeners();
      }
    });
  });
}

// NEW: Load guests and display with checkboxes in pizza night modal
async function loadGuestsIntoModal() {
  const guestSelection = document.getElementById('guestSelection');
  if (!guestSelection) return;

  try {
    const guests = await getAllGuests();

    if (guests.length === 0) {
      guestSelection.innerHTML = '<p class="text-muted text-sm">Nessun ospite salvato. Creane uno da "Gestisci Ospiti".</p>';
      return;
    }

    guestSelection.innerHTML = guests.map(guest => `
      <label style="display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; cursor: pointer; border-radius: 0.25rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
        <input type="checkbox" name="selectedGuests" value="${guest.id}" style="width: 18px; height: 18px;">
        <div style="flex: 1;">
          <div style="font-weight: 600;">${guest.name}</div>
          ${guest.email ? `<div style="font-size: 0.75rem; color: var(--color-text-secondary);">üìß ${guest.email}</div>` : '<div style="font-size: 0.75rem; color: var(--color-gray-500);">Nessuna email</div>'}
        </div>
      </label>
    `).join('');
  } catch (error) {
    console.error('Failed to load guests:', error);
    guestSelection.innerHTML = '<p class="text-muted text-sm" style="color: var(--color-error);">Errore nel caricamento ospiti</p>';
  }
}

// Setup listeners for mixed mode pizza selection
function setupMixedModeListeners() {
  const pizzaCheckboxes = document.querySelectorAll('#pizzaSelection input[type="checkbox"]');
  const fixedList = document.getElementById('fixedPizzasList');
  const generateBtn = document.getElementById('mixedGenerateBtn');

  pizzaCheckboxes.forEach(checkbox => {
    checkbox.addEventListener('change', () => {
      // Se l'utente clicca manualmente, non √® pi√π "auto-generated"
      checkbox.classList.remove('auto-generated');
      autoGeneratedPizzaIds.delete(checkbox.value);
      updateFixedPizzasList();
    });
  });
}

// Update fixed pizzas list in mixed mode
function updateFixedPizzasList() {
  const checkedBoxes = Array.from(document.querySelectorAll('#pizzaSelection input[type="checkbox"]:checked'))
    .filter(cb => !cb.classList.contains('auto-generated'));
  const fixedList = document.getElementById('fixedPizzasList');
  const generateBtn = document.getElementById('mixedGenerateBtn');

  if (checkedBoxes.length > 0) {
    const pizzaNames = Array.from(checkedBoxes).map(cb => {
      // Find the pizza name - it's in a div with font-weight: 600
      const parentDiv = cb.closest('div');
      const nameDiv = parentDiv.querySelector('div[style*="font-weight"]');
      return nameDiv ? nameDiv.textContent.trim() : 'Pizza';
    });

    fixedList.innerHTML = `
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
    ${pizzaNames.map(name => `
          <span style="padding: 0.25rem 0.75rem; background: rgba(99, 102, 241, 0.3); border-radius: 1rem; font-size: 0.875rem;">
            üìå ${name}
          </span>
        `).join('')
      }
      </div >
  `;

    if (generateBtn) generateBtn.disabled = false;
  } else {
    fixedList.innerHTML = '<p class="text-muted text-sm">Seleziona pizze dalla lista sotto...</p>';
    if (generateBtn) generateBtn.disabled = true;
  }
}

// Generate auto pizzas
async function generateAutoPizzas() {
  const numPizzas = parseInt(document.getElementById('autoNumPizzas').value);
  const resultsDiv = document.getElementById('autoResults');
  const metricsDiv = document.getElementById('metricsDisplay');

  if (!numPizzas || numPizzas < 2 || numPizzas > 20) {
    alert('Inserisci un numero valido di pizze (2-20)');
    return;
  }

  // Se ci sono pizze bloccate (PINNED), usiamo la logica Mixed per completare
  const pinnedPizzaIds = manuallySelectedPizzaIds.filter(id =>
    currentGeneratedPizzas.some(p => p.id === id)
  );

  resultsDiv.innerHTML = '<p class="text-muted">üîÑ Generazione in corso...</p>';
  resultsDiv.style.display = 'block';

  try {
    let response;
    if (pinnedPizzaIds.length > 0) {
      // Logic same as Mixed mode - complete the selection
      const numToGenerate = Math.max(1, numPizzas - pinnedPizzaIds.length);
      response = await fetch('/api/pizza-optimizer/complete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          fixedPizzaIds: pinnedPizzaIds,
          numToGenerate,
          suggestedIngredients: plannerSuggestedIngredients.map(i => i.name)
        })
      });
    } else {
      // Fresh new generation
      response = await fetch('/api/pizza-optimizer/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          numPizzas,
          suggestedIngredients: plannerSuggestedIngredients.map(i => i.name)
        })
      });
    }

    if (!response.ok) throw new Error('Errore nella generazione');

    const data = await response.json();
    const finalPizzas = data.pizzas || data.suggestions || [];

    // Se avevamo pizze bloccate, assicuriamoci che siano incluse nel display (l'API Mixed le include gi√† in data.suggestions?)
    // In realt√† l'API Mixed ritorna sia le fisse che le suggerite nel calcolo metriche, 
    // ma data.suggestions sono SOLO le nuove? Devo verificare.
    // Leggendo generateMixedPizzas esistente, sembra che data.suggestions siano quelle da aggiungere.

    let displayedPizzas = finalPizzas;
    if (pinnedPizzaIds.length > 0) {
      // Recupera gli oggetti ricetta per le pizze bloccate per mostrarle insieme ai nuovi suggerimenti
      const pinnedRecipes = currentGeneratedPizzas.filter(p => pinnedPizzaIds.includes(p.id));
      displayedPizzas = [...pinnedRecipes, ...finalPizzas];
    }

    // Uncheck ALL previous auto-generated pizzas that are NOT in the current pinned list
    document.querySelectorAll('#pizzaSelection input[type="checkbox"]:checked').forEach(checkbox => {
      if (!manuallySelectedPizzaIds.includes(checkbox.value)) {
        checkbox.checked = false;
      }
    });

    // Display results
    displayGeneratedPizzas(displayedPizzas, resultsDiv);
    displayMetrics(data.metrics, metricsDiv);

    // Auto-select these pizzas
    selectGeneratedPizzas(displayedPizzas);

  } catch (error) {
    console.error('Error generating auto pizzas:', error);
    resultsDiv.innerHTML = '<p style="color: var(--color-error);">‚ùå Errore nella generazione</p>';
  }
}

// Generate mixed pizzas
let manuallySelectedPizzaIds = []; // Track manually selected pizzas
let currentGeneratedPizzas = []; // NEW: Track currently displayed suggested pizzas
let autoGeneratedPizzaIds = new Set(); // NEW: Track which pizzas in the list are currently suggestions

async function generateMixedPizzas() {
  const allCheckedBoxes = document.querySelectorAll('#pizzaSelection input[type="checkbox"]:checked');
  const numToGenerate = parseInt(document.getElementById('mixedNumToGenerate').value);
  const resultsDiv = document.getElementById('mixedResults');
  const metricsDiv = document.getElementById('metricsDisplay');

  // Aggiorna manualmenteSelectedPizzaIds in base ai checkbox correnti
  // IMPORTANTE: Escludiamo le pizze che sono "auto-generated" (suggerimenti non ancora bloccati)
  manuallySelectedPizzaIds = Array.from(allCheckedBoxes)
    .filter(cb => !cb.classList.contains('auto-generated'))
    .map(cb => cb.value);

  if (manuallySelectedPizzaIds.length === 0) {
    alert('Seleziona almeno una pizza fissa');
    return;
  }

  if (!numToGenerate || numToGenerate < 1 || numToGenerate > 15) {
    alert('Inserisci un numero valido di pizze da generare (1-15)');
    return;
  }

  resultsDiv.innerHTML = '<p class="text-muted">üîÑ Generazione in corso...</p>';
  resultsDiv.style.display = 'block';

  try {
    const response = await fetch('/api/pizza-optimizer/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        fixedPizzaIds: manuallySelectedPizzaIds,
        numToGenerate,
        suggestedIngredients: plannerSuggestedIngredients.map(i => i.name)
      })
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || 'Errore nella generazione');
    }

    // Uncheck ALL previous auto-generated pizzas that are NOT in the current fixed list
    document.querySelectorAll('#pizzaSelection input[type="checkbox"]:checked').forEach(checkbox => {
      if (!manuallySelectedPizzaIds.includes(checkbox.value)) {
        checkbox.checked = false;
      }
    });

    const newSuggestions = data.suggestions;

    // Se avevamo suggerimenti precedenti bloccati, li preserviamo (anche se l'API /complete potrebbe averne ritornati di nuovi)
    const pinnedRecipesFromCurrent = currentGeneratedPizzas.filter(p =>
      manuallySelectedPizzaIds.includes(p.id)
    );

    // Uniamo i vecchi bloccati con i nuovi suggerimenti, evitando duplicati
    const finalSuggestions = [...pinnedRecipesFromCurrent];
    newSuggestions.forEach(p => {
      if (!finalSuggestions.some(existing => existing.id === p.id)) {
        finalSuggestions.push(p);
      }
    });

    // Display suggestions
    displayGeneratedPizzas(finalSuggestions, resultsDiv, 'Pizze Suggerite');
    displayMetrics(data.metrics, metricsDiv);

    // Auto-select suggested pizzas
    selectGeneratedPizzas(finalSuggestions);

  } catch (error) {
    console.error('Error generating mixed pizzas:', error);
    resultsDiv.innerHTML = `<p style="color: var(--color-error);">‚ùå Errore: ${error.message}</p>`;
  }
}

// Display generated pizzas
function displayGeneratedPizzas(pizzas, container, title = 'Pizze Generate') {
  currentGeneratedPizzas = pizzas;
  renderGeneratedPizzas(container, title);
}

// Internal render function to allow easy updates
function renderGeneratedPizzas(container, title = 'Pizze Generate') {
  const pizzas = currentGeneratedPizzas;
  container.innerHTML = `
    <h5 style="margin: 0 0 0.75rem 0;">${title} (${pizzas.length})</h5>
    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
      ${pizzas.map(pizza => {
    const isKept = manuallySelectedPizzaIds.includes(pizza.id);
    return `
        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: ${isKept ? 'rgba(99, 102, 241, 0.15)' : 'rgba(255,255,255,0.05)'}; border-radius: 0.5rem; border: 1px solid ${isKept ? 'var(--color-primary)' : 'transparent'};">
          <div style="flex: 1;">
            <div style="font-weight: 600;">üçï ${pizza.name} ${isKept ? '<span title="Tenuta">üìå</span>' : ''}</div>
            <div style="font-size: 0.875rem; color: var(--color-gray-400);">
              ${pizza.baseIngredients.map(i => i.name || i).join(', ')}
            </div>
          </div>
          <div style="display: flex; gap: 0.25rem;">
            <button 
              class="btn-preview-generated" 
              data-recipe-id="${pizza.id}"
              style="padding: 0.5rem; background: rgba(99, 102, 241, 0.2); border: 1px solid var(--color-primary); border-radius: 0.375rem; color: var(--color-primary); cursor: pointer; font-size: 0.875rem;"
              title="Vedi ingredienti"
            >
              üëÅÔ∏è
            </button>
            <button 
              onclick="window.toggleKeepPizza('${pizza.id}')"
              style="padding: 0.5rem; background: ${isKept ? 'var(--color-primary)' : 'rgba(255,255,255,0.1)'}; border: 1px solid ${isKept ? 'var(--color-primary)' : 'rgba(255,255,255,0.2)'}; border-radius: 0.375rem; color: white; cursor: pointer; font-size: 0.875rem;"
              title="${isKept ? 'Rimuovi dai fissi' : 'Tieni questa pizza'}"
            >
              üìå
            </button>
            <button 
              onclick="window.removeGeneratedPizza('${pizza.id}')"
              style="padding: 0.5rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.375rem; color: var(--color-error); cursor: pointer; font-size: 0.875rem;"
              title="Elimina suggerimento"
            >
              üóëÔ∏è
            </button>
          </div>
        </div>
      `;
  }).join('')}
    </div>
  `;
  container.style.display = 'block';

  // Attach preview button listeners
  container.querySelectorAll('.btn-preview-generated').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const recipeId = btn.dataset.recipeId;
      showPizzaPreviewInPlanner(recipeId);
    });
  });
}

// Handler to remove a generated pizza from suggestions
window.removeGeneratedPizza = function (recipeId) {
  currentGeneratedPizzas = currentGeneratedPizzas.filter(p => p.id !== recipeId);
  autoGeneratedPizzaIds.delete(recipeId);

  // Also uncheck in the main list
  const checkbox = document.querySelector(`#pizzaSelection input[value="${recipeId}"]`);
  if (checkbox) checkbox.checked = false;

  // Re-render
  const autoUI = document.getElementById('autoResults');
  const mixedUI = document.getElementById('mixedResults');
  const container = (autoUI && autoUI.style.display !== 'none') ? autoUI : mixedUI;

  if (container) {
    renderGeneratedPizzas(container, container.id === 'autoResults' ? 'Pizze Generate' : 'Pizze Suggerite');
  }

  // Update fixed list if it was pinned
  if (manuallySelectedPizzaIds.includes(recipeId)) {
    manuallySelectedPizzaIds = manuallySelectedPizzaIds.filter(id => id !== recipeId);
    updateFixedPizzasList();
  }
};

// Handler to toggle "keep" status of a generated pizza
window.toggleKeepPizza = function (recipeId) {
  const checkbox = document.querySelector(`#pizzaSelection input[value="${recipeId}"]`);

  if (manuallySelectedPizzaIds.includes(recipeId)) {
    manuallySelectedPizzaIds = manuallySelectedPizzaIds.filter(id => id !== recipeId);
  } else {
    manuallySelectedPizzaIds.push(recipeId);
    // Quando la blocchiamo, non √® pi√π un semplice suggerimento automatico
    autoGeneratedPizzaIds.delete(recipeId);
    if (checkbox) checkbox.classList.remove('auto-generated');
  }

  // Sync with checkboxes in the main list
  if (checkbox) checkbox.checked = manuallySelectedPizzaIds.includes(recipeId);

  // Update fixed list UI
  updateFixedPizzasList();

  // Re-render suggestions to show pinned status
  const autoUI = document.getElementById('autoResults');
  const mixedUI = document.getElementById('mixedResults');
  const container = (autoUI && autoUI.style.display !== 'none') ? autoUI : mixedUI;

  if (container) {
    renderGeneratedPizzas(container, container.id === 'autoResults' ? 'Pizze Generate' : 'Pizze Suggerite');
  }
};

// Display metrics
function displayMetrics(metrics, container) {
  const metricsContent = document.getElementById('metricsContent');
  if (!metricsContent) return;

  metricsContent.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
      <div style="text-align: center;">
        <div style="font-size: 2rem; font-weight: 700; color: var(--color-primary);">${metrics.totalScore}</div>
        <div style="font-size: 0.875rem; color: var(--color-gray-400);">Score Totale</div>
      </div>
      <div style="text-align: center;">
        <div style="font-size: 2rem; font-weight: 700; color: var(--color-success);">${metrics.ingredientReusePercent}%</div>
        <div style="font-size: 0.875rem; color: var(--color-gray-400);">Riuso Ingredienti</div>
      </div>
      <div style="text-align: center;">
        <div style="font-size: 2rem; font-weight: 700; color: var(--color-accent);">${metrics.totalIngredients}</div>
        <div style="font-size: 0.875rem; color: var(--color-gray-400);">Ingredienti Totali</div>
      </div>
    </div >
  <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 0.5rem;">
    <div style="font-weight: 600; margin-bottom: 0.5rem;">üì¶ Ingredienti:</div>
    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
      ${metrics.ingredientList.slice(0, 10).map(ing => `
          <span style="padding: 0.25rem 0.75rem; background: ${ing.shared ? 'rgba(34, 197, 94, 0.2)' : 'rgba(251, 146, 60, 0.2)'}; border-radius: 1rem; font-size: 0.875rem;">
            ${ing.shared ? '‚úì' : ''} ${ing.name}
          </span>
        `).join('')}
      ${metrics.ingredientList.length > 10 ? `<span style="color: var(--color-gray-400); font-size: 0.875rem;">+${metrics.ingredientList.length - 10} altri</span>` : ''}
    </div>
  </div>
`;

  container.style.display = 'block';
}

// Auto-select generated pizzas in the list
function selectGeneratedPizzas(pizzas) {
  // DON'T clear current selections - keep manually selected pizzas!
  // Just add the generated ones

  // Select generated pizzas
  pizzas.forEach(pizza => {
    const checkbox = document.querySelector(`#pizzaSelection input[value="${pizza.id}"]`);
    if (checkbox) {
      checkbox.checked = true;
      // Se non √® gi√† tra quelle scelte manualmente (PINNED), la marchiamo come auto-generated
      if (!manuallySelectedPizzaIds.includes(pizza.id)) {
        checkbox.classList.add('auto-generated');
        autoGeneratedPizzaIds.add(pizza.id);
      }
    }
  });
}

// ============================================
// PLANNER FILTER FUNCTIONS
// ============================================

function filterAndSortPlannerRecipes(recipes) {
  let filtered = [...recipes];

  // Tag filter
  if (plannerFilterState.selectedTag) {
    filtered = filtered.filter(r =>
      r.tags && r.tags.includes(plannerFilterState.selectedTag)
    );
  }

  // Ingredient filter
  if (plannerFilterState.selectedIngredient !== 'all') {
    filtered = filtered.filter(recipe => {
      const baseIngs = recipe.baseIngredients || [];
      const preps = recipe.preparations || [];

      const hasInBase = baseIngs.some(ing =>
        (ing.name || ing) === plannerFilterState.selectedIngredient
      );

      const hasInPrep = preps.some(prep => {
        if (!prep.ingredients) return false;
        return prep.ingredients.some(ing =>
          (ing.name || ing) === plannerFilterState.selectedIngredient
        );
      });

      return hasInBase || hasInPrep;
    });
  }

  // Sort
  switch (plannerFilterState.sortBy) {
    case 'rating':
      filtered.sort((a, b) => {
        const ratingDiff = (b.rating || 0) - (a.rating || 0);
        return ratingDiff !== 0 ? ratingDiff : b.dateAdded - a.dateAdded;
      });
      break;
    case 'az':
      filtered.sort((a, b) => a.name.localeCompare(b.name));
      break;
    case 'za':
      filtered.sort((a, b) => b.name.localeCompare(a.name));
      break;
    case 'newest':
      filtered.sort((a, b) => b.dateAdded - a.dateAdded);
      break;
    case 'oldest':
      filtered.sort((a, b) => a.dateAdded - b.dateAdded);
      break;
  }

  return filtered;
}

function populatePlannerIngredientFilter(recipes) {
  const ingredients = new Set();

  recipes.forEach(recipe => {
    (recipe.baseIngredients || []).forEach(ing => {
      ingredients.add(ing.name || ing);
    });

    (recipe.preparations || []).forEach(prep => {
      if (prep.ingredients) {
        prep.ingredients.forEach(ing => {
          ingredients.add(ing.name || ing);
        });
      }
    });
  });

  const sorted = Array.from(ingredients).sort();
  const select = document.getElementById('plannerIngredientFilter');
  if (!select) return;

  // Clear existing options except first
  select.innerHTML = '<option value="all">ü•ò Tutti gli ingredienti</option>';

  sorted.forEach(ing => {
    const option = document.createElement('option');
    option.value = ing;
    option.textContent = ing;
    select.appendChild(option);
  });
}

function renderPlannerTagFilters() {
  const container = document.getElementById('plannerTagFilters');
  if (!container) return;

  container.innerHTML = RECIPE_TAGS.map(tag => `
    <div class="filter-chip ${plannerFilterState.selectedTag === tag ? 'active' : ''}"
         data-tag="${tag}"
         style="cursor: pointer;">
      ${tag}
    </div>
  `).join('');
}

function renderPizzaSelectionList(recipes) {
  const listContainer = document.getElementById('pizzaSelection');
  if (!listContainer) return;

  if (recipes.length > 0) {
    listContainer.innerHTML = recipes.map(recipe => {
      const isAutoGenerated = autoGeneratedPizzaIds.has(recipe.id);
      const isSelected = manuallySelectedPizzaIds.includes(recipe.id) || isAutoGenerated;

      return `
            <div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem; margin-bottom: 0.5rem;">
    <input type="checkbox" name="selectedPizzas" value="${recipe.id}" ${isSelected ? 'checked' : ''} class="${isAutoGenerated ? 'auto-generated' : ''}" style="width: 20px; height: 20px;">
      <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem;">
        <button class="btn-fav-selection" data-recipe-id="${recipe.id}" data-favorite="${recipe.isFavorite ? 'true' : 'false'}" style="background: none; border: none; cursor: pointer; font-size: 1.25rem; padding: 0.25rem; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">
          ${recipe.isFavorite ? '‚≠ê' : '‚òÜ'}
        </button>
        <div style="font-weight: 600;">${recipe.name}</div>
      </div>
      <button 
        class="btn-preview-pizza" 
        data-recipe-id="${recipe.id}"
        style="padding: 0.5rem 0.75rem; background: rgba(99, 102, 241, 0.2); border: 1px solid var(--color-primary); border-radius: 0.375rem; color: var(--color-primary); cursor: pointer; font-size: 0.875rem; white-space: nowrap;"
        title="Vedi ingredienti"
      >
        üëÅÔ∏è Vedi
      </button>
      <input type="number" name="quantity_${recipe.id}" value="1" min="1" max="10" style="width: 60px; padding: 0.25rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.25rem; color: white; text-align: center;">
      </div>
      `;
    }).join('');

    // Attach listeners
    listContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        checkbox.classList.remove('auto-generated');
        autoGeneratedPizzaIds.delete(checkbox.value);
        updateFixedPizzasList();
      });
    });

    listContainer.querySelectorAll('.btn-preview-pizza').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const recipeId = btn.dataset.recipeId;
        showPizzaPreviewInPlanner(recipeId);
      });
    });

    listContainer.querySelectorAll('.btn-fav-selection').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const rid = btn.dataset.recipeId;
        try {
          const db = await import('../modules/database.js');
          await db.toggleFavorite(rid);
          // Redraw list to update stars
          const recipes = await db.getAllRecipes();
          const filtered = filterAndSortPlannerRecipes(recipes);
          renderPizzaSelectionList(filtered);
        } catch (error) {
          console.error('Failed to toggle favorite in selection:', error);
        }
      });
    });
  } else {
    listContainer.innerHTML = '<p class="text-muted" style="padding: 1rem; text-align: center;">Nessuna ricetta trovata con questo filtro.</p>';
  }
}

// ============================================
// SUGGESTED INGREDIENTS (Planner)
// ============================================

/**
 * Populate planner ingredients selector
 */
function populatePlannerIngredientsSelector(recipes) {
  const selector = document.getElementById('plannerIngredientsSelector');
  if (!selector) return;

  // Extract all ingredients from recipes with their categories
  const ingredientsMap = new Map();
  recipes.forEach(recipe => {
    (recipe.baseIngredients || []).forEach(ing => {
      const name = ing.name || ing;
      if (!ingredientsMap.has(name)) {
        ingredientsMap.set(name, ing.category || 'Altro');
      }
    });
    (recipe.preparations || []).forEach(prep => {
      if (prep.ingredients) {
        prep.ingredients.forEach(ing => {
          const name = ing.name || ing;
          if (!ingredientsMap.has(name)) {
            ingredientsMap.set(name, ing.category || 'Altro');
          }
        });
      }
    });
  });

  // Group by category
  const byCategory = {};
  ingredientsMap.forEach((category, name) => {
    if (!byCategory[category]) {
      byCategory[category] = [];
    }
    byCategory[category].push(name);
  });

  // Sort categories and ingredients
  Object.keys(byCategory).forEach(cat => {
    byCategory[cat].sort();
  });

  plannerSuggestedIngredients = [];

  selector.innerHTML = `
    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
      <div style="position: relative; flex: 1; min-width: 200px;">
        <input 
          type="text" 
          id="plannerIngredientSearch" 
          class="form-select" 
          placeholder="üîç Cerca ingrediente..."
          style="width: 100%; padding-right: 2.5rem;"
        >
        <button 
          id="plannerClearSearch" 
          style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--color-gray-400); cursor: pointer; font-size: 1.2rem; display: none;"
          title="Cancella ricerca"
        >√ó</button>
      </div>
      
      <select id="plannerIngredientSelect" class="form-select" style="flex: 1; min-width: 200px;">
        <option value="">Aggiungi ingrediente desiderato...</option>
        ${Object.entries(byCategory).sort(([a], [b]) => a.localeCompare(b)).map(([category, ings]) => `
          <optgroup label="${category}">
            ${ings.map(ing => `<option value="${ing}">${ing}</option>`).join('')}
          </optgroup>
        `).join('')}
      </select>
      
      <button type="button" class="btn btn-sm btn-primary" onclick="window.addPlannerSuggestedIngredient()" style="min-width: 44px; font-size: 1.25rem; font-weight: bold;">
        +
      </button>
    </div>
  `;

  // Add search functionality
  const searchInput = document.getElementById('plannerIngredientSearch');
  const ingredientSelect = document.getElementById('plannerIngredientSelect');
  const clearBtn = document.getElementById('plannerClearSearch');

  if (searchInput && ingredientSelect) {
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase().trim();

      // Show/hide clear button
      if (clearBtn) {
        clearBtn.style.display = searchTerm ? 'block' : 'none';
      }

      if (!searchTerm) {
        ingredientSelect.value = '';
        return;
      }

      // Find matching ingredient
      const options = ingredientSelect.querySelectorAll('option');
      for (const option of options) {
        if (option.value && option.textContent.toLowerCase().includes(searchTerm)) {
          ingredientSelect.value = option.value;
          break;
        }
      }
    });

    // Clear button functionality
    if (clearBtn) {
      clearBtn.addEventListener('click', () => {
        searchInput.value = '';
        clearBtn.style.display = 'none';
        ingredientSelect.value = '';
      });
    }
  }

  // Clear chips
  const chipsContainer = document.getElementById('plannerSelectedIngredients');
  if (chipsContainer) chipsContainer.innerHTML = '';
}

/**
 * Add suggested ingredient in planner
 */
window.addPlannerSuggestedIngredient = function () {
  const select = document.getElementById('plannerIngredientSelect');
  if (!select || !select.value) return;

  const value = select.value;
  if (plannerSuggestedIngredients.find(i => i.name === value)) return;

  plannerSuggestedIngredients.push({ name: value });
  renderPlannerSuggestedChips();
  select.value = '';
};

/**
 * Remove suggested ingredient in planner
 */
window.removePlannerSuggestedIngredient = function (name) {
  plannerSuggestedIngredients = plannerSuggestedIngredients.filter(i => i.name !== name);
  renderPlannerSuggestedChips();
};

/**
 * Render chips in planner
 */
function renderPlannerSuggestedChips() {
  const container = document.getElementById('plannerSelectedIngredients');
  if (!container) return;

  container.innerHTML = plannerSuggestedIngredients.map(ing => `
    <div class="ingredient-chip" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.3rem 0.75rem; background: var(--color-primary); color: white; border-radius: 1rem; font-size: 0.8125rem;">
      ${ing.name}
      <span onclick="window.removePlannerSuggestedIngredient('${ing.name}')" style="cursor: pointer; font-weight: bold; margin-left: 0.25rem;">‚úï</span>
    </div>
  `).join('');
}

async function showPizzaPreviewInPlanner(recipeId) {
  const recipe = await getRecipeById(recipeId);
  if (!recipe) return;

  const baseIngredients = recipe.baseIngredients || [];
  const preparations = recipe.preparations || [];

  const modalContent = `
    <div class="modal-header">
      <h2 class="modal-title">üëÅÔ∏è ${recipe.name}</h2>
      <button class="modal-close" onclick="window.closePreviewModal()">√ó</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: 1rem;">
        <div style="font-size: 0.875rem; color: var(--color-gray-400);">üë®‚Äçüç≥ ${recipe.pizzaiolo}</div>
      </div>

      ${recipe.description ? `<p style="margin-bottom: 1.5rem; color: var(--color-gray-300);">${recipe.description}</p>` : ''}

      <div class="recipe-modal-grid">
        <div>
          <h3 style="font-size: 1rem; margin-bottom: 0.75rem; color: var(--color-primary);">ü•ó Ingredienti Base</h3>
          ${baseIngredients.length > 0 ? `
            <ul style="list-style: none; padding: 0; margin: 0;">
              ${baseIngredients.map(ing => `
                <li style="padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 0.25rem; margin-bottom: 0.25rem; font-size: 0.875rem;">
                  <span style="font-weight: 600;">${ing.name}</span>
                  ${ing.quantity && ing.unit ? `<span style="color: var(--color-gray-400); float: right;">${ing.quantity} ${ing.unit}</span>` : ''}
                </li>
              `).join('')}
            </ul>
          ` : '<p style="color: var(--color-gray-500); font-size: 0.875rem;">Nessun ingrediente</p>'}
        </div>

        <div>
          <h3 style="font-size: 1rem; margin-bottom: 0.75rem; color: var(--color-accent);">ü•´ Preparazioni</h3>
          ${preparations.length > 0 ? `
            <ul style="list-style: none; padding: 0; margin: 0;">
              ${preparations.map(prep => {
    const prepData = PREPARATIONS.find(p => p.id === prep.id);
    return prepData ? `
                  <li style="padding: 0.5rem; background: rgba(249, 115, 22, 0.1); border-radius: 0.25rem; margin-bottom: 0.25rem; font-size: 0.875rem; border-left: 3px solid var(--color-accent);">
                    <span style="font-weight: 600;">${prepData.name}</span>
                    <div style="font-size: 0.75rem; color: var(--color-gray-400); margin-top: 0.25rem;">
                      ${prepData.category} ‚Ä¢ ${prepData.prepTime}
                    </div>
                  </li>
                ` : '';
  }).join('')}
            </ul>
          ` : '<p style="color: var(--color-gray-500); font-size: 0.875rem;">Nessuna preparazione</p>'}
        </div>
      </div>

      ${recipe.tags && recipe.tags.length > 0 ? `
        <div style="margin-top: 1.5rem;">
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
            ${recipe.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
          </div>
        </div>
      ` : ''}
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="window.closePreviewModal()">Chiudi</button>
    </div>
  `;

  // Use secondary modal for preview
  const previewBackdrop = document.getElementById('previewModalBackdrop');
  const previewContent = document.getElementById('previewModalContent');

  if (previewContent && previewBackdrop) {
    previewContent.innerHTML = modalContent;
    previewBackdrop.classList.add('active');
  }
}

// Helper function to close preview modal (secondary modal)
window.closePreviewModal = function () {
  const previewBackdrop = document.getElementById('previewModalBackdrop');
  if (previewBackdrop) {
    previewBackdrop.classList.remove('active');
  }
};

async function renderPizzaNights() {
  const grid = document.getElementById('pizzaNightsGrid');
  const pizzaNights = await getAllPizzaNights();

  // Sort by date, most recent first
  const sorted = pizzaNights.sort((a, b) => b.date - a.date);

  if (sorted.length === 0) {
    grid.innerHTML = `
      <div class="empty-state" style="grid-column: 1 / -1;">
        <div class="empty-icon">üéâ</div>
        <h3 class="empty-title">Nessuna serata pianificata</h3>
        <p class="empty-description">Crea la tua prima serata pizza!</p>
      </div>
    `;
    return;
  }

  grid.innerHTML = sorted.map(night => createPizzaNightCard(night)).join('');

  // Attach event listeners to card actions
  attachCardListeners(grid);
}

function attachCardListeners(container) {
  // Details buttons
  container.querySelectorAll('.btn-details').forEach(btn => {
    btn.addEventListener('click', () => {
      const nightId = btn.dataset.nightId;
      viewPizzaNightDetails(nightId);
    });
  });

  // Complete buttons
  container.querySelectorAll('.btn-complete').forEach(btn => {
    btn.addEventListener('click', () => {
      const nightId = btn.dataset.nightId;
      completePizzaNightAction(nightId);
    });
  });

  // Reopen buttons
  container.querySelectorAll('.btn-reopen').forEach(btn => {
    btn.addEventListener('click', () => {
      const nightId = btn.dataset.nightId;
      reopenPizzaNightAction(nightId);
    });
  });

  // Delete buttons
  container.querySelectorAll('.btn-delete').forEach(btn => {
    btn.addEventListener('click', () => {
      console.log('Delete button clicked');
      const nightId = btn.dataset.nightId;
      console.log('Night ID:', nightId);
      deletePizzaNightAction(nightId);
    });
  });
}

function createPizzaNightCard(night) {
  return `
      <div class="planner-card">
        <div class="planner-card-header">
          <div>
            <h3 class="planner-card-title">${night.name}</h3>
            <div class="planner-card-date">
              <span>üìÖ</span>
              <span>${formatDate(night.date)}</span>
            </div>
          </div>
          <span class="planner-card-status ${night.status}">${night.status === 'planned' ? 'Pianificata' : 'Completata'}</span>
        </div>

        <div class="planner-card-info">
          <div class="planner-info-item">
            <span class="planner-info-icon">üë•</span>
            <div>
              <div class="planner-info-label">Ospiti</div>
              <div class="planner-info-value">${night.guestCount}</div>
            </div>
          </div>
          <div class="planner-info-item">
            <span class="planner-info-icon">üçï</span>
            <div>
              <div class="planner-info-label">Pizze</div>
              <div class="planner-info-value">${night.selectedPizzas.length}</div>
            </div>
          </div>
          ${night.selectedDough ? `
          <div class="planner-info-item">
            <span class="planner-info-icon">ü•£</span>
            <div>
              <div class="planner-info-label">Impasto</div>
              <div class="planner-info-value" style="font-size: 0.875rem;">${night.selectedDough}</div>
            </div>
          </div>
        ` : ''}
        </div>

        ${night.selectedPizzas.length > 0 ? `
        <ul class="planner-pizzas-list">
          ${night.selectedPizzas.slice(0, 3).map(pizza => `
            <li class="planner-pizza-item">
              <span class="planner-pizza-name">${pizza.recipeName || 'Pizza'}</span>
              <span class="planner-pizza-quantity">√ó${pizza.quantity}</span>
            </li>
          `).join('')}
          ${night.selectedPizzas.length > 3 ? `
            <li class="planner-pizza-item text-muted">
              +${night.selectedPizzas.length - 3} altre...
            </li>
          ` : ''}
        </ul>
      ` : ''}

        ${night.notes ? `<p class="text-muted" style="font-size: 0.875rem; margin-top: 1rem;">${night.notes}</p>` : ''}

        <div class="planner-card-actions">
          <button class="btn btn-primary btn-sm btn-details" data-night-id="${night.id}">
            <span>üëÅÔ∏è</span>
            Dettagli
          </button>
          <button class="btn btn-accent btn-sm" onclick="window.location.hash='qrcodes/${night.id}'">
            <span>üé´</span>
            QR Codes
          </button>
          ${night.status === 'planned' ? `
          <button class="btn btn-secondary btn-sm btn-complete" data-night-id="${night.id}">
            <span>‚úì</span>
            Completa
          </button>
        ` : `
          <button class="btn btn-ghost btn-sm btn-reopen" data-night-id="${night.id}" title="Riporta a pianificata">
            <span>üîÑ</span>
            Ripristina
          </button>
        `}
          ${getUser()?.role === 'admin' ? `
          <button class="btn btn-ghost btn-sm btn-delete" data-night-id="${night.id}">
            <span>üóëÔ∏è</span>
          </button>
          ` : ''}
        </div>
      </div>
      `;
}

function setupPlannerListeners() {
  const newBtn = document.getElementById('newPizzaNightBtn');
  newBtn.removeEventListener('click', showNewPizzaNightModal);
  newBtn.addEventListener('click', showNewPizzaNightModal);

  const manageGuestsBtn = document.getElementById('manageGuestsBtn');
  if (manageGuestsBtn) {
    manageGuestsBtn.removeEventListener('click', showManageGuestsModal);
    manageGuestsBtn.addEventListener('click', showManageGuestsModal);
  }
}

async function showManageGuestsModal() {
  const guests = await getAllGuests();

  const modalContent = `
      <div class="modal-header">
        <h2 class="modal-title">Gestisci Ospiti</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="form-label">Aggiungi Nuovo Ospite</label>
          <div style="display: flex; flex-direction: column; gap: 0.75rem;">
            <input type="text" id="newGuestName" class="form-input" placeholder="Nome e Cognome" required>
            <input type="email" id="newGuestEmail" class="form-input" placeholder="Email (opzionale)">
            <input type="tel" id="newGuestPhone" class="form-input" placeholder="Telefono (opzionale, es. 3331234567)">
            <small style="color: var(--color-text-secondary); font-size: 0.875rem; margin-top: -0.5rem;">
              üí° Con email o telefono, puoi inviare gli inviti automaticamente
            </small>
            <button class="btn btn-primary" onclick="window.submitNewGuest()">Aggiungi Ospite</button>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">Lista Ospiti</label>
          <div id="guestsList" style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;">
            ${guests.length > 0 ? guests.map(guest => `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
              <div style="flex: 1;">
                <div style="font-weight: 600;">${guest.name}</div>
                ${guest.email ? `<div style="font-size: 0.875rem; color: var(--color-text-secondary); margin-top: 0.25rem;">üìß ${guest.email}</div>` : ''}
                ${guest.phone ? `<div style="font-size: 0.875rem; color: var(--color-text-secondary); margin-top: 0.25rem;">üì± ${guest.phone}</div>` : ''}
              </div>
              <div style="display: flex; gap: 0.5rem;">
                <button class="btn btn-ghost btn-sm" onclick="window.showEditGuestModal('${guest.id}')" title="Modifica">‚úèÔ∏è</button>
                <button class="btn btn-ghost btn-sm" onclick="window.deleteGuestAction('${guest.id}')" style="color: var(--color-error);" title="Elimina">üóëÔ∏è</button>
              </div>
            </div>
          `).join('') : '<p class="text-muted">Nessun ospite salvato.</p>'}
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.closeModal()">Chiudi</button>
      </div>
      `;

  openModal(modalContent);
}

async function submitNewGuest() {
  const nameInput = document.getElementById('newGuestName');
  const emailInput = document.getElementById('newGuestEmail');
  const phoneInput = document.getElementById('newGuestPhone');
  const name = nameInput.value.trim();
  const email = emailInput.value.trim();
  const phone = phoneInput.value.trim();

  if (!name) {
    alert('Inserisci il nome dell\'ospite');
    return;
  }

  try {
    await addGuest({ name, email: email || undefined, phone: phone || undefined });
    // Refresh modal content
    await showManageGuestsModal();
  } catch (error) {
    console.error('Failed to add guest:', error);
    alert('Errore durante l\'aggiunta dell\'ospite');
  }
}

async function deleteGuestAction(guestId) {
  if (!confirm('Sei sicuro di voler eliminare questo ospite?')) return;

  try {
    await deleteGuest(guestId);
    // Refresh modal content
    await showManageGuestsModal();
  } catch (error) {
    console.error('Failed to delete guest:', error);
  }
}

async function showEditGuestModal(guestId) {
  const guests = await getAllGuests();
  const guest = guests.find(g => g.id === guestId);

  if (!guest) {
    alert('Ospite non trovato');
    return;
  }

  const modalContent = `
      <div class="modal-header">
        <h2 class="modal-title">Modifica Ospite</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="form-label">Nome *</label>
          <input type="text" id="editGuestName" class="form-input" value="${guest.name}" required>
        </div>
        
        <div class="form-group">
          <label class="form-label">Email</label>
          <input type="email" id="editGuestEmail" class="form-input" value="${guest.email || ''}" placeholder="email@esempio.it">
        </div>
        
        <div class="form-group">
          <label class="form-label">Telefono</label>
          <input type="tel" id="editGuestPhone" class="form-input" value="${guest.phone || ''}" placeholder="3331234567">
          <small style="color: var(--color-text-secondary); font-size: 0.875rem; margin-top: 0.5rem; display: block;">
            üí° Inserisci il numero senza spazi (es. 3931234567)
          </small>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.showManageGuestsModal()">Annulla</button>
        <button class="btn btn-primary" onclick="window.updateGuestAction('${guestId}')">Salva Modifiche</button>
      </div>
      `;

  openModal(modalContent);
}

async function updateGuestAction(guestId) {
  const nameInput = document.getElementById('editGuestName');
  const emailInput = document.getElementById('editGuestEmail');
  const phoneInput = document.getElementById('editGuestPhone');

  const name = nameInput.value.trim();
  const email = emailInput.value.trim();
  const phone = phoneInput.value.trim();

  if (!name) {
    alert('Il nome √® obbligatorio');
    return;
  }

  try {
    await updateGuest(guestId, {
      name,
      email: email || null,
      phone: phone || null
    });
    // Return to guest list
    await showManageGuestsModal();
    showToast('Ospite aggiornato con successo', 'success');
  } catch (error) {
    console.error('Failed to update guest:', error);
    alert('Errore durante l\'aggiornamento dell\'ospite');
  }
}

// NEW: Send email invites to selected guests of a pizza night
async function sendGuestInvites(nightId) {
  console.log('üîµ [sendGuestInvites] Function called with nightId:', nightId);

  try {
    console.log('üîµ [sendGuestInvites] Attempting to send POST request to:', `/api/pizza-nights/${nightId}/send-invites`);

    const token = localStorage.getItem('authToken');
    console.log('üîµ [sendGuestInvites] Token exists:', !!token, 'Length:', token?.length || 0);

    const response = await fetch(`/api/pizza-nights/${nightId}/send-invites`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });

    console.log('üîµ [sendGuestInvites] Response received:', {
      status: response.status,
      statusText: response.statusText,
      ok: response.ok
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('üî¥ [sendGuestInvites] Server returned error:', errorText);
      throw new Error(`Failed to send invites: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    console.log('üîµ [sendGuestInvites] Result from server:', result);

    closeModal();

    if (result.sent > 0) {
      console.log(`‚úÖ [sendGuestInvites] Success: ${result.sent} email(s) sent`);
      showToast(`‚úÖ ${result.sent} ${result.sent === 1 ? 'email inviata' : 'email inviate'} con successo!`, 'success');
    } else {
      console.log('‚ö†Ô∏è [sendGuestInvites] No emails sent (no guests with email)');
      showToast('‚ö†Ô∏è Nessuna email inviata (nessun ospite con email)', 'warning');
    }

    if (result.failed > 0) {
      console.log(`‚ö†Ô∏è [sendGuestInvites] ${result.failed} email(s) failed`);
      showToast(`‚ö†Ô∏è ${result.failed} email non ${result.failed === 1 ? 'inviata' : 'inviate'}`, 'warning');
    }
  } catch (error) {
    console.error('üî¥ [sendGuestInvites] Error caught:', error);
    console.error('üî¥ [sendGuestInvites] Error stack:', error.stack);
    showToast('‚ùå Errore nell\'invio delle email', 'error');
  }
}

// NEW: Send WhatsApp invites to selected guests of a pizza night
async function sendWhatsAppInvites(nightId) {
  try {
    const night = await getPizzaNightById(nightId);
    if (!night) {
      showToast('‚ùå Serata non trovata', 'error');
      return;
    }

    const allGuests = await getAllGuests();
    const guestsWithPhone = night.selectedGuests
      .map(guestId => allGuests.find(g => g.id === guestId))
      .filter(g => g && g.phone);

    if (guestsWithPhone.length === 0) {
      showToast('‚ö†Ô∏è Nessun ospite ha un numero di telefono', 'warning');
      return;
    }

    // Format event time
    const eventDate = new Date(night.date);
    const eventDateStr = eventDate.toLocaleDateString('it-IT', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    const eventTimeStr = eventDate.toLocaleTimeString('it-IT', {
      hour: '2-digit',
      minute: '2-digit'
    });

    // Create modal with WhatsApp links
    const appUrl = window.location.origin;
    const modalContent = `
      <div class="modal-header">
        <h2 class="modal-title">üì± Inviti WhatsApp</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem; color: var(--color-text-secondary);">
          Clicca sui pulsanti per aprire WhatsApp e inviare l'invito a ciascun ospite:
        </p>
        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
          ${guestsWithPhone.map(guest => {
      const guestPageUrl = `${appUrl}/guest.html#guest/${nightId}/${guest.id}`;
      const message = `Ciao ${guest.name}! üçï

Sei invitato alla *${night.name}*
üìÖ ${eventDateStr}
‚è∞ ${eventTimeStr}

Visualizza i dettagli della tua serata personale:
${guestPageUrl}

Ci vediamo l√¨! üéâ`;

      const whatsappUrl = `https://wa.me/${guest.phone.replace(/[^0-9]/g, '')}?text=${encodeURIComponent(message)}`;

      return `
              <a href="${whatsappUrl}" target="_blank" class="btn btn-success" style="
                background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
                display: flex;
                align-items: center;
                justify Content: space-between;
                text-decoration: none;
                padding: 1rem;
                border-radius: 0.5rem;
                transition: transform 0.2s;
              " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                  <span style="font-size: 1.5rem;">üì±</span>
                  <div style="text-align: left;">
                    <div style="font-weight: 600;">${guest.name}</div>
                    <div style="font-size: 0.875rem; opacity: 0.9;">${guest.phone}</div>
                  </div>
                </div>
                <span style="font-size: 0.875rem; opacity: 0.9;">Apri WhatsApp ‚Üí</span>
              </a>
            `;
    }).join('')}
        </div>
        <p style="margin-top: 1rem; font-size: 0.875rem; color: var(--color-text-secondary); padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
          üí° <strong>Nota:</strong> Cliccando sui pulsanti si aprir√† WhatsApp con il messaggio gi√† pronto. Dovrai confermare l'invio manualmente.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.closeModal()">Chiudi</button>
      </div>
    `;

    openModal(modalContent);
  } catch (error) {
    console.error('Error sending WhatsApp invites:', error);
    showToast('‚ùå Errore nella generazione degli inviti WhatsApp', 'error');
  }
}

async function submitNewPizzaNight() {
  const form = document.getElementById('newPizzaNightForm');
  const formData = new FormData(form);

  const selectedPizzas = [];
  const checkboxes = form.querySelectorAll('input[name="selectedPizzas"]:checked');

  for (const checkbox of checkboxes) {
    const recipeId = checkbox.value;
    const quantity = parseInt(formData.get(`quantity_${recipeId}`)) || 1;
    const recipe = await import('../modules/database.js').then(m => m.getRecipeById(recipeId));

    selectedPizzas.push({
      recipeId,
      recipeName: recipe.name,
      quantity
    });
  }

  const selectedGuests = [];
  form.querySelectorAll('input[name="selectedGuests"]:checked').forEach(cb => {
    selectedGuests.push(cb.value);
  });

  const nightData = {
    name: formData.get('name'),
    date: new Date(formData.get('date')).getTime(),
    guestCount: parseInt(formData.get('guestCount')),
    selectedDough: formData.get('selectedDough'), // NUOVO: impasto scelto per la serata
    selectedPizzas,
    selectedGuests,
    notes: formData.get('notes') || ''
  };

  console.log('üíæ Saving pizza night with data:', nightData);
  console.log('  - selectedDough value:', nightData.selectedDough);

  try {
    await createPizzaNight(nightData);
    closeModal();
    await refreshData();
  } catch (error) {
    console.error('Failed to create pizza night:', error);
  }
}

async function viewPizzaNightDetails(nightId) {
  // Use Promise.all to fetch independent data in parallel
  const [night, allGuests] = await Promise.all([
    import('../modules/database.js').then(m => m.getPizzaNightById(nightId)),
    getAllGuests()
  ]);

  if (!night) return;

  // Ensure recipes are loaded in state for synchronous lookup
  if (!state.recipes || state.recipes.length === 0) {
    state.recipes = await getAllRecipes();
  }

  // Create a map for O(1) access to recipes
  const recipeMap = new Map(state.recipes.map(r => [r.id, r]));

  let guestNames = [];
  let guestsWithEmail = [];
  let guestsWithPhone = [];

  if (night.selectedGuests && night.selectedGuests.length > 0) {
    guestNames = night.selectedGuests.map(guestId => {
      const guest = allGuests.find(g => g.id === guestId);
      return guest ? guest.name : 'Ospite rimosso';
    });

    // Get guests with email for email button
    guestsWithEmail = night.selectedGuests
      .map(guestId => allGuests.find(g => g.id === guestId))
      .filter(g => g && g.email);

    // Get guests with phone for WhatsApp button
    guestsWithPhone = night.selectedGuests
      .map(guestId => allGuests.find(g => g.id === guestId))
      .filter(g => g && g.phone);
  }

  // Calculate ingredient counts - these can run in parallel too
  const availableIngredients = night.availableIngredients || [];

  const [fullIngredientsList, toBuyIngredientsList] = await Promise.all([
    generateShoppingList(night.selectedPizzas, night.selectedDough, [], recipeMap),
    generateShoppingList(night.selectedPizzas, night.selectedDough, availableIngredients, recipeMap)
  ]);

  const totalIngredientsCount = Object.values(fullIngredientsList).reduce((sum, list) => sum + list.length, 0);
  const toBuyCount = Object.values(toBuyIngredientsList).reduce((sum, list) => sum + list.length, 0);

  console.log('üîß [DEBUG] Rendering modal with UPDATED button order - Lista Spesa before Chiudi');

  const modalContent = `
      <div class="modal-header">
        <h2 class="modal-title">${night.name}</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <div style="position: relative; margin-bottom: 1.5rem; border-radius: 0.75rem; overflow: hidden; background: rgba(0,0,0,0.3); min-height: 200px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.1);">
          ${night.imageUrl ?
      `<img src="${night.imageUrl}" style="width: 100%; height: auto; max-height: 350px; object-fit: cover;">` :
      `<div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; color: var(--color-text-secondary); opacity: 0.5;">
                 <div style="font-size: 3rem;">üì∏</div>
                 <div style="font-size: 0.875rem;">Nessuna foto</div>
               </div>`
    }
          
          <div style="position: absolute; top: 0.75rem; right: 0.75rem; z-index: 10;">
            <button id="btnUploadNightPhoto" class="btn" onclick="document.getElementById('pizzaNightPhotoInput').click()" style="
              background: rgba(0,0,0,0.6); 
              color: white; 
              border: 1px solid rgba(255,255,255,0.2); 
              border-radius: 2rem; 
              padding: 0.5rem 1rem; 
              backdrop-filter: blur(4px);
              display: flex; 
              align-items: center; 
              gap: 0.5rem;
              font-size: 0.875rem;
              cursor: pointer;
              transition: all 0.2s;
            ">
              <span>üì∑</span> Foto
            </button>
          </div>
          <input type="file" id="pizzaNightPhotoInput" accept="image/*" style="display: none" onchange="window.handlePizzaNightPhotoUpload(this, '${night.id}')">
        </div>

        <div style="display: grid; gap: 1.5rem;">
          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">üìÖ Data</h4>
            <p>${formatDate(night.date)}</p>
          </div>

          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">üë• Ospiti</h4>
            <p>${night.guestCount} persone</p>
            ${guestNames.length > 0 ? `
            <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; margin-top: 0.5rem;">
              ${guestNames.map(name => `<span class="tag" style="background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); color: var(--color-gray-200); font-size: 0.75rem; padding: 0.2rem 0.6rem;">${name}</span>`).join('')}
            </div>
          ` : ''}
          ${guestsWithEmail.length > 0 ? `
            <div style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 0.5rem;">
              <div style="font-size: 0.875rem; color: var(--color-success); font-weight: 600; margin-bottom: 0.5rem;">
                üìß ${guestsWithEmail.length} ${guestsWithEmail.length === 1 ? 'ospite ha' : 'ospiti hanno'} un'email
              </div>
              <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                ${guestsWithEmail.map(g => `<span style="font-size: 0.75rem; color: var(--color-gray-400); background: rgba(0,0,0,0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; overflow-wrap: anywhere; word-break: break-all;">${g.email}</span>`).join('')}
              </div>
            </div>
          ` : ''}
          ${guestsWithPhone.length > 0 ? `
            <div style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(37, 211, 102, 0.1); border: 1px solid rgba(37, 211, 102, 0.3); border-radius: 0.5rem;">
              <div style="font-size: 0.875rem; color: var(--color-success); font-weight: 600; margin-bottom: 0.5rem;">
                üì± ${guestsWithPhone.length} ${guestsWithPhone.length === 1 ? 'ospite ha' : 'ospiti hanno'} WhatsApp
              </div>
              <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                ${guestsWithPhone.map(g => `<span style="font-size: 0.75rem; color: var(--color-gray-400); background: rgba(0,0,0,0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; white-space: nowrap;">${g.phone}</span>`).join('')}
              </div>
            </div>
          ` : ''}
          </div>

          ${night.selectedDough ? `
          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">ü•£ Impasto</h4>
            <p>${night.selectedDough}</p>
          </div>
        ` : ''}

          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">üçï Pizze Selezionate</h4>
            ${night.selectedPizzas.length > 0 ? `
            <ul style="list-style: none; padding: 0;">
              ${night.selectedPizzas.map((pizza, index) => {
      // Use synchronous lookup from state.recipes map
      const recipe = recipeMap.get(pizza.recipeId);
      const isFavorite = recipe ? recipe.isFavorite : false;
      const isFirst = index === 0;
      const isLast = index === night.selectedPizzas.length - 1;

      return `
                <li style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;">
                  <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1;">
                    <!-- Reorder Controls -->
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                      <button 
                        onclick="window.movePizzaUp('${nightId}', ${index})" 
                        style="background: none; border: none; cursor: pointer; font-size: 0.75rem; padding: 2px; line-height: 1; visibility: ${isFirst ? 'hidden' : 'visible'}; color: var(--color-primary-light);"
                        title="Sposta su"
                      >üîº</button>
                      <button 
                        onclick="window.movePizzaDown('${nightId}', ${index})" 
                        style="background: none; border: none; cursor: pointer; font-size: 0.75rem; padding: 2px; line-height: 1; visibility: ${isLast ? 'hidden' : 'visible'}; color: var(--color-primary-light);"
                        title="Sposta gi√π"
                      >üîΩ</button>
                    </div>

                    <button class="btn-fav-toggle" data-recipe-id="${pizza.recipeId}" data-night-id="${nightId}" data-favorite="${isFavorite ? 'true' : 'false'}" style="background: none; border: none; cursor: pointer; font-size: 1.25rem; padding: 0.25rem; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">
                       ${isFavorite ? '‚≠ê' : '‚òÜ'}
                    </button>
                    <div>
                        <span style="font-weight: 500;">${pizza.recipeName}</span>
                        ${pizza.ratings && pizza.ratings.length > 0 ? `
                            <span title="${pizza.ratings.length} voti" style="font-size: 0.75rem; background: rgba(245, 158, 11, 0.2); color: #f59e0b; padding: 2px 6px; border-radius: 4px; margin-left: 8px; font-weight: bold;">
                                ‚≠ê ${(pizza.ratings.reduce((a, b) => a + b, 0) / pizza.ratings.length).toFixed(1)}
                            </span>
                        ` : ''}
                    </div>
                  </div>
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <span style="color: var(--color-accent-light); font-weight: 700;">√ó${pizza.quantity}</span>
                    <button 
                      onclick="window.deletePizzaFromNight('${nightId}', ${index})" 
                      style="background: none; border: none; cursor: pointer; font-size: 1.1rem; padding: 0.25rem; color: #ef4444; transition: transform 0.2s;" 
                      onmouseover="this.style.transform='scale(1.2)'" 
                      onmouseout="this.style.transform='scale(1)'"
                      title="Elimina pizza"
                    >üóëÔ∏è</button>
                  </div>
                </li>
              `;
    }).join('')}
            </ul>
          ` : '<p class="text-muted">Nessuna pizza selezionata</p>'}
          </div>

          ${night.selectedPizzas.length > 0 ? `
          <div style="background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 0.75rem; padding: 1.25rem;">
            <h4 style="color: var(--color-primary-light); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
              <span>üì¶</span>
              <span>Riepilogo Dispensa</span>
            </h4>
            <div style="display: flex; gap: 2rem; align-items: center;">
              <div>
                <div style="font-size: 0.75rem; color: var(--color-gray-400); margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em;">Totale Ingredienti</div>
                <div style="font-size: 1.5rem; font-weight: 800; color: white;">${totalIngredientsCount}</div>
              </div>
              <div style="height: 30px; border-left: 2px solid rgba(255,255,255,0.1);"></div>
              <div>
                <div style="font-size: 0.75rem; color: var(--color-gray-400); margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em;">Da Acquistare</div>
                <div style="font-size: 1.5rem; font-weight: 800; color: ${toBuyCount > 0 ? 'var(--color-accent-light)' : '#10b981'};">
                  ${toBuyCount}
                </div>
              </div>
            </div>
            ${toBuyCount === 0 ? `
              <div style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem; color: #10b981; font-size: 0.875rem; font-weight: 600;">
                <span style="font-size: 1.1rem;">‚úÖ</span> Tutto in dispensa!
              </div>
            ` : `
              <div style="margin-top: 0.75rem; color: var(--color-gray-400); font-size: 0.8125rem;">
                <span style="color: #10b981; font-weight: 600;">${totalIngredientsCount - toBuyCount}</span> ingredienti gi√† disponibili su ${totalIngredientsCount} totali.
              </div>
            `}
          </div>
          ` : ''}

          ${night.notes ? `
          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">üìù Note</h4>
            <p>${night.notes}</p>
          </div>
        ` : ''}

          <div>
            <h4 style="color: var(--color-accent-light); margin-bottom: 0.5rem;">üìä Stato</h4>
            <span class="planner-card-status ${night.status}">${night.status === 'planned' ? 'Pianificata' : 'Completata'}</span>
          </div>
        </div>
      </div>
      <div class="modal-footer" style="flex-direction: column; align-items: stretch; gap: 0.75rem;">
        ${guestsWithEmail.length > 0 ? `
        <button class="btn btn-success" onclick="window.sendGuestInvites('${night.id}')" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
          <span>üìß</span>
          Invia Email Inviti (${guestsWithEmail.length})
        </button>
      ` : ''}
        ${guestsWithPhone.length > 0 ? `
        <button class="btn btn-success" onclick="window.sendWhatsAppInvites('${night.id}')" style="background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);">
          <span>üì±</span>
          Inviti WhatsApp (${guestsWithPhone.length})
        </button>
      ` : ''}
        ${night.selectedPizzas.length > 0 && night.status === 'planned' ? `
        <button class="btn btn-accent" onclick="window.startLiveMode('${night.id}')" style="background: linear-gradient(135deg, #f97316 0%, #dc2626 100%);">
          <span>üçï</span>
          Avvia Serata
        </button>
      ` : ''}
        ${night.selectedPizzas.length > 0 ? `
        <button class="btn btn-secondary" onclick="window.closeModal(); setTimeout(() => window.manageAvailableIngredients('${night.id}'), 100);">
          <span>‚úì</span>
          Ingredienti
        </button>
        <button class="btn btn-secondary" onclick="window.closeModal(); setTimeout(() => window.viewPizzaNightPreparations('${night.id}'), 100);">
          <span>üß™</span>
          Preparazioni
        </button>
        <button class="btn btn-primary" onclick="window.closeModal(); setTimeout(() => window.viewShoppingListForNight('${night.id}'), 100);">
          <span>üõí</span>
          Lista Spesa
        </button>
      ` : ''}
        <button class="btn btn-secondary" onclick="window.closeModal()">Chiudi</button>
      </div>
      `;

  console.log('üîç [DEBUG] Modal footer buttons order check:');
  console.log('  - Email button:', guestsWithEmail.length > 0 ? 'YES' : 'NO');
  console.log('  - WhatsApp button:', guestsWithPhone.length > 0 ? 'YES' : 'NO');
  console.log('  - Avvia Serata button:', (night.selectedPizzas.length > 0 && night.status === 'planned') ? 'YES' : 'NO');
  console.log('  - Ingredienti/Preparazioni/Lista Spesa buttons:', night.selectedPizzas.length > 0 ? 'YES (all 3 together)' : 'NO');
  console.log('  - Chiudi button: ALWAYS YES');

  openModal(modalContent);

  // Setup favorite toggle listeners
  setTimeout(() => {
    const modal = document.querySelector('.modal');
    if (modal) {
      modal.querySelectorAll('.btn-fav-toggle').forEach(btn => {
        btn.onclick = async (e) => {
          e.stopPropagation();
          const rid = btn.dataset.recipeId;
          const nid = btn.dataset.nightId;
          try {
            const db = await import('../modules/database.js');
            await db.toggleFavorite(rid);

            // Check if we need to update our cached recipes to reflect the change
            const recipeIndex = state.recipes.findIndex(r => r.id === rid);
            if (recipeIndex >= 0) {
              state.recipes[recipeIndex].isFavorite = !state.recipes[recipeIndex].isFavorite;
            }

            // Re-render details to show updated star
            await viewPizzaNightDetails(nid);
          } catch (error) {
            console.error('Failed to toggle favorite:', error);
            showToast('Errore nel cambio preferiti', 'error');
          }
        };
      });
    }
  }, 100);
}

// Function to move a pizza up in the list
window.movePizzaUp = async function (nightId, index) {
  console.log(`‚¨ÜÔ∏è[PLANNER] movePizzaUp called for index ${index}`);
  if (index <= 0) return;
  try {
    const { getPizzaNightById, updatePizzaNight } = await import('../modules/database.js');
    const night = await getPizzaNightById(nightId);
    if (!night) return;

    // Swap items
    const pizzas = [...night.selectedPizzas];
    const temp = pizzas[index];
    pizzas[index] = pizzas[index - 1];
    pizzas[index - 1] = temp;

    console.log('üîÑ [PLANNER] New order being saved:', pizzas.map(p => p.recipeName));

    // Update database
    const updated = await updatePizzaNight(nightId, { ...night, selectedPizzas: pizzas });
    console.log('‚úÖ [PLANNER] Database update response:', updated);

    // Re-render modal and grid
    console.log('‚ôªÔ∏è [PLANNER] Refreshing details...');
    await viewPizzaNightDetails(nightId);
    await renderPizzaNights();
  } catch (error) {
    console.error('Failed to move pizza up:', error);
    showToast('Errore nel riordinamento', 'error');
  }
};

// Function to move a pizza down in the list
window.movePizzaDown = async function (nightId, index) {
  console.log(`‚¨áÔ∏è[PLANNER] movePizzaDown called for index ${index}`);
  try {
    const { getPizzaNightById, updatePizzaNight } = await import('../modules/database.js');
    const night = await getPizzaNightById(nightId);
    if (!night || index >= night.selectedPizzas.length - 1) return;

    // Swap items
    const pizzas = [...night.selectedPizzas];
    const temp = pizzas[index];
    pizzas[index] = pizzas[index + 1];
    pizzas[index + 1] = temp;

    console.log('üîÑ [PLANNER] New order being saved:', pizzas.map(p => p.recipeName));

    // Update database
    const updated = await updatePizzaNight(nightId, { ...night, selectedPizzas: pizzas });
    console.log('‚úÖ [PLANNER] Database update response:', updated);

    // Re-render modal and grid
    console.log('‚ôªÔ∏è [PLANNER] Refreshing details...');
    await viewPizzaNightDetails(nightId);
    await renderPizzaNights();
  } catch (error) {
    console.error('Failed to move pizza down:', error);
    showToast('Errore nel riordinamento', 'error');
  }
};

// Function to delete a pizza from the night
window.deletePizzaFromNight = async function (nightId, index) {
  console.log(`üóëÔ∏è [PLANNER] deletePizzaFromNight called for index ${index}`);
  try {
    const { getPizzaNightById, updatePizzaNight } = await import('../modules/database.js');
    const night = await getPizzaNightById(nightId);
    if (!night || index < 0 || index >= night.selectedPizzas.length) return;

    // Get the pizza name before removing it
    const pizzaName = night.selectedPizzas[index].recipeName;

    // Remove the pizza at the specified index
    const pizzas = [...night.selectedPizzas];
    pizzas.splice(index, 1);

    console.log('üîÑ [PLANNER] Removing pizza:', pizzaName);
    console.log('üîÑ [PLANNER] Remaining pizzas:', pizzas.map(p => p.recipeName));

    // Update database
    const updated = await updatePizzaNight(nightId, { ...night, selectedPizzas: pizzas });
    console.log('‚úÖ [PLANNER] Database update response:', updated);

    // Show success message
    showToast(`‚úÖ Pizza "${pizzaName}" rimossa dalla serata`, 'success');

    // Re-render modal and grid
    console.log('‚ôªÔ∏è [PLANNER] Refreshing details...');
    await viewPizzaNightDetails(nightId);
    await renderPizzaNights();
  } catch (error) {
    console.error('Failed to delete pizza:', error);
    showToast('‚ùå Errore nell\'eliminazione della pizza', 'error');
  }
};

// ============================================
// VIEW PIZZA NIGHT PREPARATIONS
// ============================================

async function viewPizzaNightPreparations(nightId) {
  closeModal();

  // Get pizza night data
  const night = await getPizzaNightById(nightId);
  if (!night) return;

  try {
    const { getRecipeById, getAllPreparations } = await import('../modules/database.js');

    // Resolve all recipes to collect preparations
    const recipes = await Promise.all(
      night.selectedPizzas.map(item => getRecipeById(item.recipeId))
    );

    // Collect unique preparation IDs
    const prepIds = new Set();
    recipes.forEach(recipe => {
      if (recipe.preparations) {
        recipe.preparations.forEach(p => prepIds.add(p.id));
      }
    });

    if (prepIds.size === 0) {
      showToast('Nessuna preparazione richiesta per questa serata');
      viewPizzaNightDetails(nightId);
      return;
    }

    // Get all preparations details
    const allPrepsData = await getAllPreparations();
    const nightPreps = allPrepsData.filter(p => prepIds.has(p.id));

    // Build modal HTML
    let prepsHTML = nightPreps.map(prep => `
      <div style="background: rgba(255,255,255,0.05); border-radius: 1rem; padding: 1.5rem; margin-bottom: 1.5rem; border-left: 4px solid var(--color-accent-light);">
        <h3 style="color: var(--color-accent-light); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
          <span>üß™</span> ${prep.name}
        </h3>
        
        <div style="margin-bottom: 1rem;">
          <h4 style="font-size: 0.875rem; color: var(--color-gray-400); margin-bottom: 0.5rem; text-transform: uppercase;">Ingredienti</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${prep.ingredients.map(ing => `
              <span style="background: rgba(255,255,255,0.1); padding: 0.25rem 0.75rem; border-radius: 2rem; font-size: 0.8125rem;">
                ${ing.name}: ${ing.quantity}${ing.unit}
              </span>
            `).join('')}
          </div>
        </div>
        
        <div>
          <h4 style="font-size: 0.875rem; color: var(--color-gray-400); margin-bottom: 0.5rem; text-transform: uppercase;">Procedimento</h4>
          <p style="white-space: pre-wrap; line-height: 1.6;">${prep.instructions}</p>
        </div>
      </div>
    `).join('');

    const modalContent = `
      <div class="modal-header">
        <h2>üß™ Preparazioni - ${night.name}</h2>
        <button class="modal-close" onclick="window.viewPizzaNightDetails('${nightId}')">√ó</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--color-gray-300); margin-bottom: 1.5rem;">
          Queste sono le preparazioni necessarie per le pizze selezionate (topping e salse speciali).
        </p>
        <div class="preparations-list">
          ${prepsHTML}
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.viewPizzaNightDetails('${nightId}')">Indietro</button>
        <button class="btn btn-primary" onclick="window.closeModal()">Chiudi</button>
      </div>
    `;

    openModal(modalContent);
  } catch (error) {
    console.error('Failed to load preparations:', error);
    showToast('Errore nel caricamento delle preparazioni', 'error');
    viewPizzaNightDetails(nightId);
  }
}

// Make it global
window.viewPizzaNightPreparations = viewPizzaNightPreparations;

// ============================================
// MANAGE AVAILABLE INGREDIENTS
// ============================================

async function manageAvailableIngredients(nightId) {
  closeModal();

  // Get pizza night data
  const night = await getPizzaNightById(nightId);
  if (!night) return;

  // Generate FULL ingredient list (without filtering)
  const fullList = await generateShoppingList(night.selectedPizzas, night.selectedDough, []);

  // Get currently available ingredients
  const availableIngredients = night.availableIngredients || [];

  // Helper to get category icon (aligned with new hierarchical structure)
  const getCategoryIcon = (category) => {
    const icons = {
      'Impasti': 'üåæ',
      'Basi e Salse': 'üçÖ',
      'Formaggi': 'ÔøΩ',
      'Latticini': 'ü•õ',
      'Carni e Salumi': 'ü•ì',
      'Pesce e Frutti di Mare': 'üêü',
      'Verdure e Ortaggi': 'ÔøΩ',
      'Erbe e Spezie': 'üåø',
      'Frutta e Frutta Secca': 'ü•ú',
      'Altro': 'üì¶'
    };
    return icons[category] || 'üì¶';
  };

  // Build items HTML with checkboxes
  let itemsHTML = '';
  for (const [category, items] of Object.entries(fullList)) {
    const icon = getCategoryIcon(category);
    itemsHTML += `
      <div class="shopping-category" data-category="${category}">
        <h3 class="category-title">${icon} ${category}</h3>
        <div class="shopping-items">
          ${items.map(item => {
      const isChecked = availableIngredients.some(avail =>
        avail.toLowerCase() === item.name.toLowerCase()
      );
      const pizzaCountBadge = item.pizzaCount ? `<span style="font-size: 0.75rem; color: var(--color-primary-light); margin-left: 0.5rem;">(${item.pizzaCount} pizze)</span>` : '';
      return `
            <div class="shopping-item ${isChecked ? 'checked' : ''}">
              <div class="shopping-item-checkbox ${isChecked ? 'checked' : ''}" 
                   onclick="this.classList.toggle('checked'); this.closest('.shopping-item').classList.toggle('checked');">
              </div>
              <div class="shopping-item-content">
                <span class="item-name" data-ingredient-name="${item.name}">${item.name}${pizzaCountBadge}</span>
                <span class="item-quantity">${formatQuantity(item.quantity, item.unit)}</span>
              </div>
            </div>
          `;
    }).join('')}
        </div>
      </div>
  `;
  }

  // Create and show modal
  const modalContent = `
      <div class="modal-header">
        <h2>‚úì Ingredienti Disponibili - ${night.name}</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--color-gray-300); margin-bottom: 1.5rem;">
          Seleziona gli ingredienti che hai gi√† in casa. La lista spesa mostrer√† solo quelli da acquistare.
        </p>
        
        <!-- Quick Select Buttons -->
        <div style="display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
          <button class="btn btn-secondary btn-sm" onclick="window.quickSelectDough()">
            <span>üåæ</span> Tutto l'impasto
          </button>
          <button class="btn btn-secondary btn-sm" onclick="window.quickSelectSpices()">
            <span>üåø</span> Spezie base
          </button>
          <button class="btn btn-secondary btn-sm" onclick="window.quickSelectAll()">
            <span>‚úì</span> Seleziona tutto
          </button>
          <button class="btn btn-secondary btn-sm" onclick="window.quickSelectNone()">
            <span>‚úó</span> Azzera tutto
          </button>
        </div>
        
        <div class="shopping-list-container">
          ${itemsHTML}
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.closeModal()">
          Annulla
        </button>
        <button class="btn btn-primary" onclick="window.saveAvailableIngredients('${nightId}')">
          üíæ Salva
        </button>
      </div>
`;

  openModal(modalContent);
}

// Save available ingredients selection
async function saveAvailableIngredients(nightId) {
  // Get all checked ingredients
  const checkedItems = document.querySelectorAll('.shopping-item.checked .item-name');
  const availableIngredients = Array.from(checkedItems).map(el => el.dataset.ingredientName);

  try {
    // Get the full night object
    const night = await getPizzaNightById(nightId);
    if (!night) throw new Error('Pizza night not found');

    // Update availableIngredients
    night.availableIngredients = availableIngredients;

    // Use the database module's updatePizzaNight function which includes authentication
    await updatePizzaNight(nightId, night);

    closeModal();
    showToast(`‚úÖ ${availableIngredients.length} ingredienti salvati come disponibili`, 'success');

    // Refresh the local state and re-open details to show updated counters
    await renderPizzaNights();
    setTimeout(() => viewPizzaNightDetails(nightId), 300);
  } catch (error) {
    console.error('Error saving available ingredients:', error);
    showToast('‚ùå Errore nel salvare gli ingredienti', 'error');
  }
}

// Expose function globally
window.saveAvailableIngredients = saveAvailableIngredients;

// Quick select functions
function quickSelectDough() {
  // Select all items in "Impasto" category
  const doughCategory = document.querySelector('.shopping-category[data-category="Impasto"]');
  if (doughCategory) {
    const items = doughCategory.querySelectorAll('.shopping-item');
    items.forEach(item => {
      item.classList.add('checked');
      const checkbox = item.querySelector('.shopping-item-checkbox');
      if (checkbox) checkbox.classList.add('checked');
    });
  }
}

function quickSelectSpices() {
  // Select all items in "Erbe e Spezie" category
  const spiceCategory = document.querySelector('.shopping-category[data-category="Erbe e Spezie"]');
  if (spiceCategory) {
    const items = spiceCategory.querySelectorAll('.shopping-item');
    items.forEach(item => {
      item.classList.add('checked');
      const checkbox = item.querySelector('.shopping-item-checkbox');
      if (checkbox) checkbox.classList.add('checked');
    });
  }
}

function quickSelectAll() {
  // Select all items
  const allItems = document.querySelectorAll('.shopping-item');
  allItems.forEach(item => {
    item.classList.add('checked');
    const checkbox = item.querySelector('.shopping-item-checkbox');
    if (checkbox) checkbox.classList.add('checked');
  });
}

function quickSelectNone() {
  // Deselect all items
  const allItems = document.querySelectorAll('.shopping-item');
  allItems.forEach(item => {
    item.classList.remove('checked');
    const checkbox = item.querySelector('.shopping-item-checkbox');
    if (checkbox) checkbox.classList.remove('checked');
  });
}

async function viewShoppingListForNight(nightId) {
  closeModal();

  // Get pizza night data
  const night = await getPizzaNightById(nightId);
  if (!night) return;

  // Generate shopping list (filtered by available ingredients)
  const groupedList = await generateShoppingList(night.selectedPizzas, night.selectedDough, night.availableIngredients || []);

  // Helper to get category icon
  const getCategoryIcon = (category) => {
    const icons = {
      'Impasto': 'üåæ',
      'Salsa': 'üçÖ',
      'Formaggi': 'üßÄ',
      'Carne': 'ü•ì',
      'Verdure': 'ü•¨',
      'Pesce': 'üêü',
      'Latticini': 'ü•õ',
      'Erbe e Spezie': 'üåø',
      'Altro': 'üì¶'
    };
    return icons[category] || 'üì¶';
  };

  // Build items HTML
  let itemsHTML = '';
  for (const [category, items] of Object.entries(groupedList)) {
    const icon = getCategoryIcon(category);
    itemsHTML += `
      <div class="shopping-category">
        <h3 class="category-title">${icon} ${category}</h3>
        <div class="shopping-items">
          ${items.map(item => {
      const pizzaCountBadge = item.pizzaCount ? `<span style="font-size: 0.75rem; color: var(--color-primary-light); margin-left: 0.5rem;">(${item.pizzaCount} pizze)</span>` : '';
      return `
            <div class="shopping-item">
              <div class="shopping-item-checkbox" onclick="this.classList.toggle('checked'); this.closest('.shopping-item').classList.toggle('checked');"></div>
              <div class="shopping-item-content">
                <span class="item-name">${item.name}${pizzaCountBadge}</span>
                <span class="item-quantity">${formatQuantity(item.quantity, item.unit)}</span>
              </div>
            </div>
          `;
    }).join('')}
        </div>
      </div>
  `;
  }

  // Create and show modal
  const modalContent = `
      <div class="modal-header">
        <h2>üõí Lista Spesa - ${night.name}</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div>
      <div class="modal-body">
        <div class="shopping-list-container">
          ${itemsHTML}
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.closeModal()">
          Chiudi
        </button>
        <button class="btn btn-primary" onclick="window.downloadShoppingListForNight('${nightId}', '${night.name}')">
          üì• Scarica PDF
        </button>
        <button class="btn btn-primary" style="margin-left: 0.5rem; background-color: #e53935; border-color: #e53935;" onclick="window.openBringModal('${nightId}')">
          <span>üõí</span>
          Bring!
        </button>
      </div>
`;

  openModal(modalContent);
}

// Helper function for downloading shopping list from modal
async function downloadShoppingListForNight(nightId, nightName) {
  const night = await getPizzaNightById(nightId);
  const groupedList = await generateShoppingList(night.selectedPizzas, night.selectedDough, night.availableIngredients || []);
  downloadShoppingList(groupedList, nightName);
}

// Local action functions
async function completePizzaNightAction(nightId) {
  try {
    const db = await import('../modules/database.js');
    await db.updatePizzaNight(nightId, { status: 'completed' });
    showToast('‚úÖ Serata completata!', 'success');
    await renderPizzaNights();
  } catch (error) {
    console.error('Failed to complete pizza night:', error);
    showToast('‚ùå Errore nel completare la serata', 'error');
  }
}

async function reopenPizzaNightAction(nightId) {
  try {
    const db = await import('../modules/database.js');
    await db.updatePizzaNight(nightId, { status: 'planned' });
    showToast('üîÑ Serata riportata a pianificata', 'info');
    await renderPizzaNights();
  } catch (error) {
    console.error('Failed to reopen pizza night:', error);
    showToast('‚ùå Errore nel ripristinare la serata', 'error');
  }
}

async function deletePizzaNightAction(nightId) {
  const modalContent = `
      <div class="modal-header">
        <h2 class="modal-title">Elimina Serata</h2>
        <button class="modal-close" onclick="window.closeModal()">√ó</button>
      </div >
      <div class="modal-body">
        <p>Sei sicuro di voler eliminare questa serata? L'azione non pu√≤ essere annullata.</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="window.closeModal()">Annulla</button>
        <button class="btn btn-primary" style="background-color: var(--color-error, #ef4444);" onclick="window.confirmDeletePizzaNight('${nightId}')">
          <span>üóëÔ∏è</span> Elimina
        </button>
      </div>
`;
  openModal(modalContent);
}

async function confirmDeletePizzaNight(nightId) {
  try {
    await deletePizzaNight(nightId);
    closeModal();
    await refreshData();
    // Show success toast?
  } catch (error) {
    console.error('Failed to delete pizza night:', error);
  }
}

// ==========================================
// PHOTO UPLOAD
// ==========================================
window.handlePizzaPhotoUploadV2 = async function (input) {
  const file = input.files[0];
  if (!file) return;

  const pizza = liveModeState.pizzas[liveModeState.currentIndex];
  if (!pizza) return;

  // Show loading state
  const btn = document.getElementById('btnUploadPhoto');
  const originalText = btn.innerHTML;
  btn.innerHTML = '<span>‚è≥</span> Elaborazione...';
  btn.disabled = true;

  try {
    // 1. Read file
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onload = function (e) {
      const img = new Image();
      img.src = e.target.result;

      img.onload = async function () {
        // 2. Resize and Compress
        const canvas = document.createElement('canvas');
        const MAX_WIDTH = 1200;
        let width = img.width;
        let height = img.height;

        if (width > MAX_WIDTH) {
          height *= MAX_WIDTH / width;
          width = MAX_WIDTH;
        }

        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);

        // Compress to JPEG 80%
        const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
        console.log(`üì∏ Image compressed: ${(compressedBase64.length / 1024).toFixed(2)} KB`);

        // 3. Upload
        try {
          // Import auth or fallback to direct localStorage
          let token;
          try {
            const { getToken } = await import('../modules/auth.js');
            token = getToken();
          } catch (e) {
            token = localStorage.getItem('authToken');
          }

          console.log('üîê [Upload] Token value:', token);

          if (!token || token === 'null' || token === 'undefined') {
            alert('‚ö†Ô∏è Non sei loggato! Verrai reindirizzato al login.');
            window.location.href = '/login.html';
            btn.innerHTML = originalText;
            btn.disabled = false;
            return;
          }

          const response = await fetch(`/api/recipes/${pizza.id}/image`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ imageBase64: compressedBase64 })
          });

          console.log('üì° [Upload] Response Status:', response.status);
          // ALert for debugging to force visibility
          if (response.status === 401 || response.status === 403) {
            alert(`‚õî DEBUG: Rilevato errore ${response.status}. Reindirizzamento...`);
            console.error('‚õî Auth Error:', response.status);
            localStorage.removeItem('authToken');
            window.location.href = '/login.html';
            return;
          }

          if (!response.ok) {
            const errText = await response.text();
            // Unique error message to verify version
            throw new Error(`[DEBUG_V2] Server responded with ${response.status}: ${errText}`);
          }

          if (!response.ok) {
            // throw new Error('Upload failed');
            const errText = await response.text();
            throw new Error(`[DEBUG_V2] Server responded with ${response.status}: ${errText}`);
          }

          const data = await response.json();

          // UPDATE STATE so navigation works
          if (liveModeState && liveModeState.pizzas[liveModeState.currentIndex]) {
            liveModeState.pizzas[liveModeState.currentIndex].imageUrl = data.imageUrl;
          }

          // 4. Update UI
          const imageContainer = document.getElementById('liveImageContainer');

          if (imageContainer) {
            imageContainer.innerHTML = `
                <img src="${compressedBase64}" 
                     class="pizza-live-image" 
                     style="width: 100%; max-height: 300px; object-fit: cover; border-radius: 0.5rem; display: block;" 
                     alt="Nuova foto">
              `;
            imageContainer.style.display = 'block';
          }

          // Update button text
          btn.innerHTML = '<span>‚úÖ</span> Foto Salvata!';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.disabled = false;
          }, 2000);

        } catch (err) {
          console.error('Upload error:', err);
          btn.innerHTML = '<span>‚ùå</span> Errore';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.disabled = false;
          }, 2000);
        }
      };
    };

  } catch (err) {
    console.error('File reading error:', err);
    btn.innerHTML = '<span>‚ùå</span> Errore';
    btn.disabled = false;
  }
};

// ============================================
// LIVE MODE FUNCTIONS
// ============================================

let liveModeState = {
  nightId: null,
  pizzas: [],
  currentIndex: 0,
  checkedIngredients: {},
  checkedPreparations: {}
};

async function startLiveMode(nightId) {
  try {
    // Fetch pizza night data
    const night = await getPizzaNightById(nightId);

    console.log('üîç Night data:', night);
    console.log('üîç selectedDough from DB:', night.selectedDough);
    console.log('üîç Full night object:', JSON.stringify(night, null, 2));

    if (!night || !night.selectedPizzas || night.selectedPizzas.length === 0) {
      alert('Nessuna pizza trovata per questa serata!');
      return;
    }

    // Load full recipe data for each selected pizza
    const pizzas = [];
    for (const selectedPizza of night.selectedPizzas) {
      const recipeId = selectedPizza.recipeId || selectedPizza.id;
      const recipe = await getRecipeById(recipeId);


      if (recipe) {
        // Add quantity info to recipe
        recipe.quantity = selectedPizza.quantity || 1;

        // Load full preparation data if preparations exist
        if (recipe.preparations && recipe.preparations.length > 0) {
          const fullPreparations = [];
          for (const prep of recipe.preparations) {
            if (typeof prep === 'object' && prep.id) {
              // Load full preparation data from database
              const { getPreparationById } = await import('../modules/database.js');
              const fullPrep = await getPreparationById(prep.id);
              if (fullPrep) {
                // Merge quantity/timing info with full preparation data
                fullPreparations.push({
                  ...fullPrep,
                  quantity: prep.quantity,
                  unit: prep.unit,
                  timing: prep.timing
                });
              } else {
                // Fallback if preparation not found
                fullPreparations.push({ name: prep.id, ...prep });
              }
            } else {
              // Already a string or full object
              fullPreparations.push(prep);
            }
          }
          recipe.preparations = fullPreparations;
        }

        pizzas.push(recipe);
        console.log(`Pushed pizza: ${recipe.name}, imageUrl: ${recipe.imageUrl}`);
      }
    }

    if (pizzas.length === 0) {
      alert('Impossibile caricare i dati delle pizze!');
      return;
    }

    // Calculate cooking instructions based on oven temp and dough type
    let maxOvenTemp = 250;
    try {
      const userSettings = await getUserSettings();
      maxOvenTemp = parseInt(userSettings?.maxOvenTemp || '250');
    } catch (err) {
      console.warn('Failed to fetch user settings for cooking calculation:', err);
    }
    const doughType = night.selectedDough || 'default';

    console.log('üî• Cooking calculation:');
    console.log('  - maxOvenTemp:', maxOvenTemp);
    console.log('  - doughType from night:', doughType);
    console.log('  - night.selectedDough:', night.selectedDough);

    const cookingInfo = getCookingInstructions(doughType, maxOvenTemp);

    console.log('  - cookingInfo result:', cookingInfo);

    // Initialize state
    liveModeState.nightId = nightId;
    liveModeState.pizzas = pizzas;
    liveModeState.currentIndex = 0;
    liveModeState.checkedIngredients = {};
    liveModeState.checkedPreparations = {};
    liveModeState.checkedIngredients = {};
    liveModeState.checkedPreparations = {};
    liveModeState.cookingInstructions = cookingInfo.formatted;

    // Show live mode UI
    const container = document.getElementById('liveModeContainer');
    if (container) {
      container.style.display = 'flex';
      document.body.style.overflow = 'hidden'; // Prevent scroll

      // Close modal first
      closeModal();

      // Setup swipe gestures for mobile
      setupSwipeGestures(container);

      // Render first pizza after DOM is ready
      setTimeout(() => {
        renderLivePizza();
      }, 0);
    }
  } catch (error) {
    console.error('Failed to start live mode:', error);
    console.error('Error stack:', error.stack);
    console.error('Error message:', error.message);
    alert('Errore nell\'avvio della serata: ' + error.message);
  }
}

// Setup swipe gestures for mobile navigation
function setupSwipeGestures(container) {
  // Prevent duplicate listeners
  if (container.dataset.swipeInitialized) return;
  container.dataset.swipeInitialized = 'true';

  let touchStartX = 0;
  let touchEndX = 0;
  let touchStartY = 0;
  let touchEndY = 0;
  let isSwiping = false;

  const minSwipeDistance = 50; // Minimum distance for a swipe
  const maxVerticalDistance = 100; // Maximum vertical movement to still count as horizontal swipe

  container.addEventListener('touchstart', (e) => {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
    isSwiping = false;
  }, { passive: true });

  container.addEventListener('touchmove', (e) => {
    // Detect if this is a horizontal swipe
    const currentX = e.changedTouches[0].screenX;
    const currentY = e.changedTouches[0].screenY;
    const diffX = Math.abs(currentX - touchStartX);
    const diffY = Math.abs(currentY - touchStartY);

    // If horizontal movement is greater than vertical, it's a swipe
    if (diffX > diffY && diffX > 10) {
      isSwiping = true;
      // Prevent browser back/forward gesture
      e.preventDefault();
    }
  }, { passive: false }); // Must be non-passive to use preventDefault

  container.addEventListener('touchend', (e) => {
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    handleGesture();
  }, { passive: true });

  function handleGesture() {
    const horizontalDistance = touchEndX - touchStartX;
    const verticalDistance = Math.abs(touchEndY - touchStartY);

    // Only trigger swipe if horizontal movement is significant
    // and vertical movement is minimal (to avoid interfering with scrolling)
    if (Math.abs(horizontalDistance) > minSwipeDistance && verticalDistance < maxVerticalDistance) {
      if (horizontalDistance < 0) {
        // Swipe left - next pizza
        nextPizza();
      } else {
        // Swipe right - previous pizza
        previousPizza();
      }
    }
  }
}

function renderLivePizza() {
  const pizza = liveModeState.pizzas[liveModeState.currentIndex];
  const total = liveModeState.pizzas.length;
  const current = liveModeState.currentIndex + 1;

  // Update progress
  document.querySelector('.progress-indicator').textContent =
    `Pizza ${current} di ${total} `;

  // Update pizza name
  document.querySelector('.pizza-name').textContent = pizza.name || 'Pizza';

  // Handle Image Display
  const imageContainer = document.getElementById('liveImageContainer');

  if (imageContainer) {
    if (pizza.imageUrl) {
      imageContainer.innerHTML = `
            <img src="${pizza.imageUrl}?t=${Date.now()}" 
                 class="pizza-live-image" 
                 style="width: 100%; max-height: 300px; object-fit: cover; border-radius: 0.5rem; display: block;" 
                 alt="${pizza.name}">
        `;
      imageContainer.style.display = 'block';
    } else {
      imageContainer.innerHTML = '';
      imageContainer.style.display = 'none';
    }
  } else {
    // Fallback if container is missing (should not happen with new HTML)
    console.error('liveImageContainer not found!');
  }

  // Separate ingredients and preparations by phase
  // Combine all possible ingredient arrays for the recipe
  const ingredients = [
    ...(pizza.baseIngredients || []),
    ...(pizza.toppingsDuringBake || []),
    ...(pizza.ingredients || [])
  ];

  // Add post-bake toppings and mark them
  const postBakeToppings = (pizza.toppingsPostBake || []).map(ing => ({
    ...ing,
    postBake: true
  }));

  const allIngredients = [...ingredients, ...postBakeToppings];
  const preparations = pizza.preparations || [];

  console.log('üîç Live Mode Debug:');
  console.log('  - Pizza:', pizza.name);
  console.log('  - All ingredients:', allIngredients);
  console.log('  - preparations:', preparations);

  const beforeIngredients = allIngredients.filter(ing => !ing.postBake || ing.postBake === 0 || ing.postBake === '0');
  const afterIngredients = allIngredients.filter(ing => !!ing.postBake && (ing.postBake === true || ing.postBake === 1 || ing.postBake === 'true' || ing.postBake === '1'));

  console.log('  - beforeIngredients count:', beforeIngredients.length);
  console.log('  - afterIngredients count:', afterIngredients.length);
  if (afterIngredients.length > 0) {
    console.log('  - afterIngredients:', afterIngredients);
  }

  // For preparations, some might have 'timing' property and others might be in separate lists if we added them in parser
  // But currently parser puts them in instructions, not separate arrays. 
  // However, we should check if they have timing 'after' or 'post-bake'
  const beforePreparations = preparations.filter(prep => !prep.timing || (prep.timing !== 'after' && prep.timing !== 'post-bake'));
  const afterPreparations = preparations.filter(prep => prep.timing === 'after' || prep.timing === 'post-bake');

  // Render BEFORE cooking content
  renderCookingPhaseContent('beforeCookingContent', beforeIngredients, beforePreparations, 'before');

  // Render AFTER cooking content
  renderCookingPhaseContent('afterCookingContent', afterIngredients, afterPreparations, 'after');

  // Update cooking instructions
  const cookingInstructionsEl = document.getElementById('liveCookingInstructions');
  if (cookingInstructionsEl && liveModeState.cookingInstructions) {
    cookingInstructionsEl.textContent = liveModeState.cookingInstructions;
  }

  // Update navigation buttons
  updateLiveNavigation();
}

function renderCookingPhaseContent(containerId, ingredients, preparations, phase) {
  const container = document.getElementById(containerId);
  if (!container) return;

  let html = '';

  // Check if there's any content for this phase
  if (ingredients.length === 0 && preparations.length === 0) {
    html = `<p class="text-muted" style="text-align: center; padding: 2rem;">Nessun ingrediente o preparazione per questa fase</p>`;
    container.innerHTML = html;
    return;
  }

  // Render ingredients for this phase
  if (ingredients.length > 0) {
    html += '<div style="margin-bottom: 1.5rem;">';
    html += '<div class="ingredient-grid">';

    html += ingredients.map((ing, i) => {
      const ingName = ing.name || ing;
      const quantity = ing.quantity || '';
      const unit = ing.unit || '';

      return `
        <div class="ingredient-item">
          <span>${ingName}${quantity ? ` - ${quantity}${unit}` : ''}</span>
        </div>
      `;
    }).join('');

    html += '</div></div>';
  }

  // Render preparations for this phase
  if (preparations.length > 0) {
    html += '<div><h4 style="color: var(--color-primary-light); margin-bottom: 1rem;">üë®‚Äçüç≥ Preparazioni</h4>';
    html += '<div class="preparation-steps">';

    html += preparations.map((prep, i) => {
      let prepName = '';
      if (typeof prep === 'string') {
        prepName = prep;
      } else if (prep && typeof prep === 'object') {
        prepName = prep.name || prep.preparationName || prep.id || 'Preparazione';
      } else {
        prepName = 'Preparazione';
      }

      return `
        <div class="step">
          <span>${prepName}</span>
        </div>
      `;
    }).join('');

    html += '</div></div>';
  }

  container.innerHTML = html;
}

function saveIngredientCheck(index, checked) {
  const checkKey = `${liveModeState.currentIndex}-ing-${index}`;
  liveModeState.checkedIngredients[checkKey] = checked;
}

function savePrepCheck(index, checked) {
  const checkKey = `${liveModeState.currentIndex}-prep-${index}`;
  liveModeState.checkedPreparations[checkKey] = checked;
}

function updateLiveNavigation() {
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnComplete = document.getElementById('btnComplete');

  if (!btnPrev || !btnNext || !btnComplete) return;

  // Show/hide previous button
  btnPrev.style.display = liveModeState.currentIndex > 0 ? 'block' : 'none';

  // Show next or complete button
  const isLast = liveModeState.currentIndex === liveModeState.pizzas.length - 1;
  btnNext.style.display = isLast ? 'none' : 'block';
  btnComplete.style.display = isLast ? 'block' : 'none';
}

function previousPizza() {
  if (liveModeState.currentIndex > 0) {
    liveModeState.currentIndex--;
    renderLivePizza();

    // Scroll to top
    const container = document.getElementById('liveModeContainer');
    if (container) container.scrollTop = 0;
  }
}

function nextPizza() {
  if (liveModeState.currentIndex < liveModeState.pizzas.length - 1) {
    liveModeState.currentIndex++;
    renderLivePizza();

    // Scroll to top
    const container = document.getElementById('liveModeContainer');
    if (container) container.scrollTop = 0;
  }
}

async function completePizzaNightLive() {
  if (confirm('Segnare la serata come completata?')) {
    try {
      const db = await import('../modules/database.js');
      await db.updatePizzaNight(liveModeState.nightId, { status: 'completed' });
      exitLiveMode();
      await renderPizzaNights(); // Refresh list
      showToast('üéâ Serata completata! Alla prossima!', 'success');
    } catch (error) {
      console.error('Failed to complete pizza night:', error);
      showToast('‚ùå Errore nel completare la serata: ' + error.message, 'error');
    }
  }
}

function exitLiveMode() {
  const container = document.getElementById('liveModeContainer');
  if (container) {
    container.style.display = 'none';
  }
  document.body.style.overflow = 'auto';

  // Reset state
  liveModeState = {
    nightId: null,
    pizzas: [],
    currentIndex: 0,
    checkedIngredients: {},
    checkedPreparations: {}
  };
}

// NEW: Handle Pizza Night Photo Upload
window.handlePizzaNightPhotoUpload = async function (input, nightId) {
  if (input.files && input.files[0]) {
    const file = input.files[0];
    const btn = document.getElementById('btnUploadNightPhoto');
    const originalContent = btn.innerHTML;

    // Show loading state
    btn.disabled = true;
    btn.innerHTML = '<span>‚è≥</span> Caricamento...';

    try {
      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = async function () {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          // Resize logic (max 1200px)
          const MAX_WIDTH = 1200;
          const MAX_HEIGHT = 1200;

          if (width > height) {
            if (width > MAX_WIDTH) {
              height *= MAX_WIDTH / width;
              width = MAX_WIDTH;
            }
          } else {
            if (height > MAX_HEIGHT) {
              width *= MAX_HEIGHT / height;
              height = MAX_HEIGHT;
            }
          }

          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          // Compress to JPEG with 70% quality
          const dataUrl = canvas.toDataURL('image/jpeg', 0.7);

          console.log(`üì∏ Uploading photo for night ${nightId}, size: ${(dataUrl.length / 1024).toFixed(2)}KB`);

          // Upload to server
          // Import auth
          const { getToken } = await import('../modules/auth.js');
          const token = getToken();

          if (!token) {
            alert('‚ö†Ô∏è Devi effettuare il login per caricare le foto!');
            btn.innerHTML = originalContent;
            btn.disabled = false;
            return;
          }

          const response = await fetch(`/api/pizza-nights/${nightId}/image`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ imageBase64: dataUrl })
          });

          if (response.status === 401) {
            console.warn('‚õî Token rejected by server (401). Redirecting to login.');
            alert('‚ö†Ô∏è Sessione scaduta. Effettua nuovamente il login.');
            // Clear invalid token
            const { removeToken } = await import('../modules/auth.js');
            removeToken();
            window.location.href = '/login.html';
            return;
          }

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server error: ${errorText}`);
          }

          const result = await response.json();
          console.log('‚úÖ Photo uploaded successfully:', result);

          showToast('Foto caricata con successo!', 'success');

          // Refresh the modal to show the new image
          await viewPizzaNightDetails(nightId);

          // Also refresh the main list if needed (optional)
          await refreshData();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    } catch (error) {
      console.error('Failed to upload photo:', error);
      showToast('Errore durante il caricamento della foto', 'error');

      // Reset button
      btn.disabled = false;
      btn.innerHTML = originalContent;
    }
  }
};


// Global functions for modals (still needed for inline onclick in modals)
window.viewPizzaNightDetails = viewPizzaNightDetails;
window.submitNewPizzaNight = submitNewPizzaNight;
window.manageAvailableIngredients = manageAvailableIngredients;
window.saveAvailableIngredients = saveAvailableIngredients;
window.quickSelectDough = quickSelectDough;
window.quickSelectSpices = quickSelectSpices;
window.quickSelectAll = quickSelectAll;
window.quickSelectNone = quickSelectNone;
window.viewShoppingListForNight = viewShoppingListForNight;
window.downloadShoppingListForNight = downloadShoppingListForNight;
window.completePizzaNightAction = completePizzaNightAction;
window.deletePizzaNightAction = deletePizzaNightAction;
window.confirmDeletePizzaNight = confirmDeletePizzaNight;
window.showManageGuestsModal = showManageGuestsModal;
window.submitNewGuest = submitNewGuest;
window.showEditGuestModal = showEditGuestModal;
window.updateGuestAction = updateGuestAction;
window.deleteGuestAction = deleteGuestAction;
window.sendGuestInvites = sendGuestInvites;
window.sendWhatsAppInvites = sendWhatsAppInvites;
window.generateAutoPizzas = generateAutoPizzas;
window.generateMixedPizzas = generateMixedPizzas;
window.startLiveMode = startLiveMode;
window.exitLiveMode = exitLiveMode;
window.previousPizza = previousPizza;
window.nextPizza = nextPizza;
window.completePizzaNightLive = completePizzaNightLive;
window.reopenPizzaNightAction = reopenPizzaNightAction;
window.saveIngredientCheck = saveIngredientCheck;
window.savePrepCheck = savePrepCheck;
